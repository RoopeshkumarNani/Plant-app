<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>My Soulmates</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸŒ¿</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="/config.js"></script>
    <style>
        :root {
            --bg: #f4fbf6;
            --card: #ffffff;
            --accent: #2d6a4f;
            --accent-2: #7ac488;
            --muted: #6b7280;
            --glass: rgba(255, 255, 255, 0.6)
        }

        * {
            box-sizing: border-box
        }

        body {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Arial;
            color: #0b2f1a;
            padding: 18px;
            -webkit-font-smoothing: antialiased;
            /* background image with gentle overlay for readability */
            background-image: url('/Background_plant.png');
            background-size: cover;
            background-position: center center;
            background-repeat: no-repeat;
            background-attachment: fixed;
        }

        @media (max-width: 640px) {
            body {
                padding: 12px;
            }
        }

        @media (max-width: 420px) {
            body {
                padding: 10px;
            }
        }

        /* fill the viewport so we can make panels height-relative and scroll independently */
        html,
        body {
            height: 100%;
            margin: 0;
        }

        .container {
            max-width: 980px;
            margin: 0 auto;
            position: relative;
            z-index: 2;
            /* sit above background overlay */
            display: flex;
            flex-direction: column;
            height: 100dvh;
            /* Dynamic viewport height - accounts for mobile UI like address bar */
            padding: 16px;
            box-sizing: border-box;
        }

        .hero {
            display: flex;
            flex-direction: column;
            gap: 4px;
            /* Reduced from 8px */
            align-items: center;
            margin-bottom: 16px;
            /* Reduced from 24px */
            justify-content: center;
            text-align: center;
        }

        .hero h1 {
            font-size: 1.5rem;
            /* Reduced from 2rem */
            font-weight: 700;
            color: #1A365D;
            text-shadow: 0 1px 3px rgba(255, 255, 255, 0.3);
            margin: 0;
            letter-spacing: -0.5px;
        }

        .hero p {
            font-size: 0.75rem;
            /* Reduced from 0.85rem */
            font-weight: 700;
            color: #000000;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.2);
            margin: 0;
            letter-spacing: 0.8px;
            /* Reduced from 1px */
        }

        .logo {
            display: flex;
            gap: 4px;
            /* Reduced from 6px */
            align-items: center;
            padding: 6px 10px;
            /* Reduced from 8px 12px */
            flex-wrap: nowrap;
            background: linear-gradient(135deg, #2d6a4f, #1b4332);
            border-radius: 8px;
            /* Reduced from 10px */
            font-weight: 800;
            font-size: 0.9rem;
            /* Reduced from 1rem */
            color: #ffffff;
            text-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
            letter-spacing: 0.5px;
        }

        /* allow input to shrink on small screens */
        .composer input#replyText {
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid #e6f3ea;
            flex: 1 1 auto;
            min-width: 0;
            outline: none
        }

        .composer button {
            padding: 8px 10px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            flex: 0 0 auto
        }

        .composer #voiceBtn {
            background: linear-gradient(135deg, #52b788, #40916c);
            color: #fff;
            font-size: 20px;
            width: 44px;
            height: 40px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            box-shadow: 0 6px 14px rgba(45, 106, 79, 0.12);
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            outline: none;
            line-height: 1;
        }

        .composer #sendReply {
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            color: #fff;
            font-weight: 700;
            width: 44px;
            height: 40px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            box-shadow: 0 6px 14px rgba(45, 106, 79, 0.12);
            border: none;
            cursor: pointer;
            font-size: 18px;
            line-height: 1
        }

        .composer #speakLast {
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            color: #fff;
            width: 44px;
            height: 40px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            box-shadow: 0 6px 14px rgba(45, 106, 79, 0.12);
            border: none;
            cursor: pointer;
            font-size: 18px;
            line-height: 1
        }

        /* On very small screens, make buttons slightly smaller to avoid wrapping */
        @media (max-width:480px) {
            .composer {
                gap: 6px
            }

            .composer #sendReply {
                width: 40px;
                height: 36px;
                font-size: 16px
            }
        }

        header h1 {
            margin: 0;
            font-weight: 700;
            font-size: 20px;
            text-align: center;
            color: #000;
            /* match other headings (pure black) */
        }

        /* ensure panel headings match and are clearly visible */
        .panel h3,
        .panel h4 {
            color: #000;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 360px;
            gap: 18px;
            height: 100%;
            /* allow panels to fill available vertical space */
            align-items: stretch;
            overflow: hidden;
        }

        @media (max-width: 880px) {
            .grid {
                grid-template-columns: 1fr;
                gap: 12px;
                display: flex;
                flex-direction: column;
            }

            .grid .panel:first-child {
                flex: 2;
                min-height: 0;
            }

            .grid .panel.chat {
                flex: 1;
                min-height: 0;
            }

            .panel {
                padding: 14px;
                min-height: auto;
            }

            .hero {
                margin-bottom: 12px;
                /* Reduced from 16px */
            }
        }

        @media (max-width: 640px) {
            .grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .grid .panel:first-child {
                flex: 1 1 auto;
                /* Changed to allow more flexibility */
                min-height: 200px;
                /* Ensure plants panel has minimum space */
                overflow: visible;
                /* Ensure plants are visible */
            }

            .grid .panel.chat {
                flex: 0 0 auto;
                /* Changed from flex: 1 to prevent taking too much space */
                min-height: 120px;
                /* Further reduced for very short screens */
                max-height: 40vh;
                /* Limit chat height to 40% of viewport */
            }
        }

        /* Special handling for very short viewports (like 330px height) */
        @media (max-width: 640px) and (max-height: 400px) {
            .grid .panel:first-child {
                min-height: 150px;
                /* Reduced minimum for very short screens */
            }

            .grid .panel.chat {
                min-height: 100px;
                /* Even smaller for very short screens */
                max-height: 35vh;
                /* Further limit chat height */
            }

            .hero {
                margin-bottom: 8px;
                /* Reduce header space */
            }
        }

        /* Responsive language dropdown - prevent overlapping on small screens */
        @media (max-width: 640px) {
            header.hero>div:last-child {
                top: 12px !important;
                right: 12px !important;
            }
        }

        @media (max-width: 480px) {
            header.hero>div:last-child {
                top: 8px !important;
                right: 8px !important;
            }

            header.hero>div:last-child select {
                padding: 6px 10px !important;
                font-size: 12px !important;
            }
        }

        .panel {
            padding: 12px;
            min-height: auto;
        }

        .hero {
            margin-bottom: 10px;
            /* Reduced from 14px */
            gap: 3px;
            /* Reduced gap */
        }

        .hero h1 {
            font-size: 1.3rem;
            /* Reduced from 1.6rem */
        }

        .hero p {
            font-size: 0.7rem;
            /* Reduced from 0.75rem */
            letter-spacing: 0.5px;
        }

        .logo {
            padding: 5px 8px;
            /* Reduced padding for mobile */
            font-size: 0.85rem;
            /* Reduced font size */
        }

        .file-area {
            width: 120px;
            height: 90px;
        }

        /* Plant cards: single column on mobile */
        .plant-card {
            width: 100%;
            flex-direction: row;
            gap: 12px;
            align-items: center;
        }

        .plant-card img {
            width: 90px;
            /* Increased from 80px for better visibility */
            height: 70px;
            /* Increased from 60px for better visibility */
            flex-shrink: 0;
            object-fit: contain;
            /* Show full image without cropping */
        }

        .plant-name {
            font-size: 14px;
        }

        .plant-meta {
            font-size: 12px;
        }

        .messages {
            padding: 10px;
            gap: 10px;
        }

        .composer {
            padding: 8px;
            gap: 6px;
        }

        .msg {
            max-width: 82%;
        }

        .pill {
            padding: 8px 10px;
            font-size: 12px;
        }

        @media (max-width: 420px) {
            .file-area {
                width: 100px;
                height: 80px;
            }

            /* Make tab buttons visible and easy to tap on mobile */
            #tab-plants,
            #tab-flowers {
                padding: 6px 10px;
                font-size: 12px;
                min-height: 36px;
                border-radius: 8px;
                flex: 0 1 auto;
            }

            #searchBox {
                padding: 6px 8px;
                font-size: 12px;
                min-height: 36px;
            }

            #openUploadBtn {
                padding: 6px 10px;
                min-height: 36px;
                font-size: 12px;
            }

            .grid .panel:first-child {
                flex: 1 1 auto;
                /* Changed to allow flexibility */
                min-height: 180px;
                /* Ensure plants panel has minimum space */
            }

            .grid .panel.chat {
                flex: 0 0 auto;
                min-height: auto;
                max-height: 35vh;
                /* Limit chat height on very small screens */
            }

            #chatPanel {
                display: flex;
                flex-direction: column;
                height: auto;
            }

            #chatHeader {
                display: none;
            }

            .messages {
                display: none;
            }

            #historyContainer,
            #managePhotosContainer,
            #growthChartContainer,
            #healthDashboard {
                display: none !important;
            }

            #typingIndicator {
                display: none !important;
            }

            .composer {
                flex-direction: row;
                gap: 3px;
                padding: 3px;
                display: flex;
                align-items: center;
                border-top: none;
            }

            .composer #replyText {
                width: auto;
                flex: 1 1 auto;
                font-size: 11px;
                padding: 4px 6px;
                min-height: 28px;
            }

            .composer button {
                font-size: 10px;
                padding: 2px 4px;
                min-height: 26px;
                min-width: 26px;
                width: auto;
                height: 26px;
            }

            .composer #voiceBtn {
                width: 26px;
                height: 26px;
                padding: 0;
                display: inline-flex;
                align-items: center;
                justify-content: center;
            }

            .composer #sendReply {
                width: 50px;
                font-size: 9px;
            }

            .composer #speakLast {
                width: 26px;
                height: 26px;
                padding: 0;
                display: inline-flex;
                align-items: center;
                justify-content: center;
            }

            .panel {
                padding: 8px;
            }

            .plants {
                gap: 6px;
            }

            .hero h1 {
                font-size: 1.2rem;
                /* Reduced from 1.4rem */
                margin-bottom: 1px;
                /* Reduced from 2px */
            }

            .hero p {
                font-size: 0.6rem;
                /* Reduced from 0.65rem */
            }

            .hero {
                margin-bottom: 8px;
                /* Reduced from 10px */
                gap: 2px;
                /* Reduced from 4px */
            }

            .logo {
                padding: 4px 7px;
                /* Further reduced for very small screens */
                font-size: 0.75rem;
                /* Smaller font */
            }

            .messages {
                padding: 6px;
                gap: 6px;
                border-radius: 8px;
            }

            .msg {
                max-width: 85%;
                padding: 8px;
                border-radius: 10px;
                font-size: 13px;
            }

            .composer {
                padding: 4px;
                gap: 3px;
            }

            /* Responsive header controls for mobile */
            #tab-plants,
            #tab-flowers {
                padding: 5px 8px;
                font-size: 12px;
            }

            #searchBox {
                padding: 5px 8px;
                font-size: 11px;
                max-width: none;
                min-width: auto;
            }

            #openUploadBtn {
                padding: 5px 8px;
                font-size: 12px;
            }

            .pill {
                padding: 6px 8px;
                font-size: 11px;
            }
        }

        /* Responsive header for tablets and smaller tablets */
        @media (max-width: 640px) {

            #tab-plants,
            #tab-flowers {
                padding: 8px 14px;
                font-size: 14px;
                white-space: nowrap;
                min-height: 40px;
                border-radius: 10px;
            }

            #searchBox {
                padding: 8px 12px;
                font-size: 14px;
                max-width: none;
                min-width: 100px;
                min-height: 40px;
            }

            #openUploadBtn {
                padding: 8px 14px;
                min-height: 40px;
                white-space: nowrap;
            }
        }

        .panel {
            background: rgba(255, 255, 255, 0.82);
            border-radius: 14px;
            padding: 18px;
            box-shadow: 0 16px 40px rgba(10, 30, 18, 0.12);
            position: relative;
            z-index: 3;
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
            display: flex;
            flex-direction: column;
            /* let panels size to grid area height */
            height: 100%;
        }

        /* subtle overlay to improve contrast on text-heavy areas */
        .bg-overlay {
            position: fixed;
            inset: 0;
            background: rgba(242, 255, 246, 0.28);
            pointer-events: none;
            z-index: 0;
        }

        .upload-row {
            display: block;
            max-width: 500px;
            margin: 0 auto;
        }

        /* Elegant upload card - concise and compact */
        .upload-card {
            display: flex;
            gap: 12px;
            align-items: flex-start;
            padding: 10px;
            border-radius: 10px;
            border: 1px solid rgba(28, 67, 42, 0.08);
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.94), rgba(250, 255, 250, 0.92));
            box-shadow: 0 6px 16px rgba(20, 50, 20, 0.04);
        }

        /* upload panel collapsed/expanded */
        #uploadPanel.collapsed {
            display: none
        }

        #uploadPanel.expanded {
            display: block
        }

        .file-area {
            width: 140px;
            height: 100px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(180deg, #f1fbf3, #fbfff9);
            border: 1px dashed rgba(34, 100, 60, 0.08);
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }

        .file-area.drag-over {
            background: linear-gradient(180deg, #eaffef, #f7fff7);
            border-color: rgba(34, 140, 60, 0.35);
            box-shadow: inset 0 0 0 4px rgba(122, 196, 136, 0.06);
        }

        .file-btn {
            display: inline-block;
            padding: 10px 12px;
            background: transparent;
            border-radius: 8px;
            color: var(--accent);
            font-weight: 600;
            cursor: pointer;
            border: 1px solid rgba(45, 106, 79, 0.08);
        }

        #photoPreview {
            max-width: 100%;
            max-height: 100%;
            display: block;
            object-fit: cover;
            width: 100%;
            height: 100%;
        }

        .upload-fields {
            flex: 1;
            display: flex;
            gap: 10px;
            flex-direction: column
        }

        .pill {
            padding: 10px 12px;
            border-radius: 999px;
            border: 1px solid rgba(230, 243, 234, 0.9);
            background: #fff;
        }

        /* Tabs */
        #tab-plants,
        #tab-flowers {
            padding: 10px 16px;
            border-radius: 10px;
            border: 1px solid rgba(45, 106, 79, 0.15);
            background: rgba(255, 255, 255, 0.5);
            color: #0b2f1a;
            cursor: pointer;
            font-weight: 600;
            transition: all 150ms ease;
        }

        #tab-plants:hover,
        #tab-flowers:hover {
            background: rgba(255, 255, 255, 0.8);
            border-color: rgba(45, 106, 79, 0.25);
        }

        #tab-plants.active,
        #tab-flowers.active {
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            color: #fff;
            box-shadow: 0 8px 18px rgba(45, 106, 79, 0.12);
            border: none;
        }

        #tab-plants.active:hover,
        #tab-flowers.active:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 22px rgba(45, 106, 79, 0.18);
        }

        /* search box styling */
        #searchBox {
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid rgba(45, 106, 79, 0.1);
            background: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            color: #0b2f1a;
            flex: 1;
            min-width: 120px;
        }

        #searchBox::placeholder {
            color: rgba(11, 47, 26, 0.5);
        }

        #searchBox:focus {
            outline: none;
            border-color: var(--accent);
            background: #fff;
            box-shadow: 0 0 0 2px rgba(45, 106, 79, 0.1);
        }

        /* small badge for flowers */
        .badge {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            color: var(--accent);
            padding: 6px 8px;
            border-radius: 999px;
            font-weight: 700;
            font-size: 12px;
            box-shadow: 0 6px 10px rgba(20, 40, 20, 0.06);
        }

        /* plant / flower card visuals - base styles (removed duplicate, using main definition below) */

        .plant-card .plant-name {
            font-weight: 700;
            color: #0b2f1a;
        }

        .plant-card .small {
            color: var(--muted);
            font-size: 13px
        }

        /* manage button inside card - compact circular three-dots control */
        .plant-manage {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 34px;
            height: 34px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.88);
            border-radius: 50%;
            padding: 0;
            font-size: 16px;
            line-height: 1;
            cursor: pointer;
            color: var(--muted);
            border: 1px solid rgba(20, 50, 20, 0.06);
            box-shadow: 0 6px 14px rgba(10, 30, 18, 0.06);
            z-index: 6;
        }

        /* ensure badge doesn't sit on top of manage button */
        .plant-card .badge {
            left: 10px;
            top: 10px;
            z-index: 2
        }

        .plant-card .plant-manage {
            z-index: 3
        }

        button.primary {
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            box-shadow: 0 8px 22px rgba(45, 106, 79, 0.12);
        }

        .composer button {
            padding: 8px 10px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            flex: 0 0 auto
        }

        .composer #voiceBtn {
            background: linear-gradient(135deg, #52b788, #40916c);
            color: #fff;
            font-size: 20px;
            width: 44px;
            height: 40px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            box-shadow: 0 6px 14px rgba(45, 106, 79, 0.12);
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            outline: none;
            line-height: 1;
        }

        .composer #sendReply {
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            color: #fff;
            font-weight: 700;
            width: 44px;
            height: 40px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            box-shadow: 0 6px 14px rgba(45, 106, 79, 0.12);
            border: none;
            cursor: pointer;
            font-size: 18px;
            line-height: 1
        }

        .composer #speakLast {
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            color: #fff;
            width: 44px;
            height: 40px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            box-shadow: 0 6px 14px rgba(45, 106, 79, 0.12);
            border: none;
            cursor: pointer;
            font-size: 18px;
            line-height: 1
        }

        /* On very small screens, make buttons slightly smaller to avoid wrapping */
        @media (max-width:480px) {
            .composer {
                gap: 6px
            }

            .composer #sendReply {
                width: 40px;
                height: 36px;
                font-size: 16px
            }
        }

        header h1 {
            margin: 0;
            font-weight: 700;
            font-size: 20px;
            text-align: center;
            color: #000;
            /* match other headings (pure black) */
        }

        /* ensure panel headings match and are clearly visible */
        .panel h3,
        .panel h4 {
            color: #000;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 360px;
            gap: 18px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.82);
            border-radius: 14px;
            padding: 18px;
            box-shadow: 0 16px 40px rgba(10, 30, 18, 0.12);
            position: relative;
            z-index: 3;
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 0;
        }

        /* subtle overlay to improve contrast on text-heavy areas */
        .bg-overlay {
            position: fixed;
            inset: 0;
            background: rgba(242, 255, 246, 0.28);
            pointer-events: none;
            z-index: 0;
        }

        .upload-row {
            display: block;
            max-width: 500px;
            margin: 0 auto;
        }

        /* Elegant upload card - concise and compact */
        .upload-card {
            display: flex;
            gap: 12px;
            align-items: flex-start;
            padding: 10px;
            border-radius: 10px;
            border: 1px solid rgba(28, 67, 42, 0.08);
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.94), rgba(250, 255, 250, 0.92));
            box-shadow: 0 6px 16px rgba(20, 50, 20, 0.04);
        }

        /* upload panel collapsed/expanded */
        #uploadPanel.collapsed {
            display: none
        }

        #uploadPanel.expanded {
            display: block
        }

        .file-area {
            width: 140px;
            height: 100px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(180deg, #f1fbf3, #fbfff9);
            border: 1px dashed rgba(34, 100, 60, 0.08);
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }

        .file-btn {
            display: inline-block;
            padding: 10px 12px;
            background: transparent;
            border-radius: 8px;
            color: var(--accent);
            font-weight: 600;
            cursor: pointer;
            border: 1px solid rgba(45, 106, 79, 0.08);
        }

        #photoPreview {
            max-width: 100%;
            max-height: 100%;
            display: block;
            object-fit: cover;
            width: 100%;
            height: 100%;
        }

        .upload-fields {
            flex: 1;
            display: flex;
            gap: 8px;
            flex-direction: column;
            min-width: 0;
        }

        .pill {
            padding: 8px 10px;
            border-radius: 999px;
            border: 1px solid rgba(230, 243, 234, 0.9);
            background: #fff;
            font-size: 0.9rem;
        }

        /* Tabs */
        #tab-plants,
        #tab-flowers {
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid rgba(45, 106, 79, 0.06);
            background: transparent;
            cursor: pointer;
        }

        #tab-plants.active,
        #tab-flowers.active {
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            color: #fff;
            box-shadow: 0 8px 18px rgba(45, 106, 79, 0.12);
        }

        #tab-plants.active:hover,
        #tab-flowers.active:hover {
            transform: translateY(-1px);
        }

        /* small badge for flowers */
        .badge {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            color: var(--accent);
            padding: 6px 8px;
            border-radius: 999px;
            font-weight: 700;
            font-size: 12px;
            box-shadow: 0 6px 10px rgba(20, 40, 20, 0.06);
        }

        button.primary {
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            box-shadow: 0 8px 22px rgba(45, 106, 79, 0.12);
        }

        button.ghost {
            background: transparent;
            border: 1px solid rgba(45, 106, 79, 0.08);
            color: var(--accent);
        }

        /* small ghost buttons in headers */
        .ghost.small {
            padding: 6px 8px;
            font-size: 13px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(45, 106, 79, 0.08);
            color: var(--accent);
        }

        .ghost.small:hover {
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 6px 14px rgba(20, 50, 20, 0.06);
        }

        /* Active state for filter buttons */
        .ghost.small.active {
            background: linear-gradient(135deg, var(--accent-2), var(--accent));
            color: white;
            border: 1px solid var(--accent);
            box-shadow: 0 4px 12px rgba(45, 106, 79, 0.2);
            font-weight: 600;
        }

        .ghost.small.active:hover {
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            box-shadow: 0 6px 16px rgba(45, 106, 79, 0.3);
        }

        /* FAB removed: manage control lives in the chat header now */

        input[type=file] {
            padding: 10px;
            border-radius: 10px;
            border: 1px dashed #dcefe0;
            background: #fff;
            box-shadow: 0 6px 14px rgba(20, 60, 30, 0.04);
            color: #123a23;
        }

        input[type=text] {
            padding: 10px;
            border-radius: 10px;
            border: 1px solid #e6f3ea;
            background: #fff;
            min-width: 120px;
            box-shadow: inset 0 -4px 12px rgba(0, 0, 0, 0.02);
        }

        button {
            background: var(--accent);
            color: white;
            border: 0;
            padding: 10px 14px;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 6px 12px rgba(45, 106, 79, 0.12)
        }

        /* ensure buttons are readable on background */
        button,
        button.ghost {
            z-index: 4;
        }

        button.ghost {
            background: transparent;
            color: var(--accent);
            border: 1px solid rgba(45, 106, 79, 0.08)
        }

        /* wrapper for plants list - takes up remaining space */
        .panel>div:last-child {
            display: flex;
            flex: 1;
            min-height: 0;
            /* Ensure wrapper is always visible */
            visibility: visible !important;
            opacity: 1 !important;
        }

        .plants {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 12px;
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
            align-content: flex-start;
            padding-right: 4px;
            padding-bottom: 8px;
            /* Added bottom padding to prevent cards from being cut off */
            scrollbar-width: thin;
            scrollbar-color: #b8d4b8 rgba(180, 200, 180, 0.08);
            /* Ensure plants container is always visible */
            visibility: visible !important;
            opacity: 1 !important;
        }

        .plants::-webkit-scrollbar {
            width: 7px;
        }

        .plants::-webkit-scrollbar-track {
            background: rgba(180, 200, 180, 0.08);
        }

        .plants::-webkit-scrollbar-thumb {
            background: #b8d4b8;
            border-radius: 3px;
        }

        .plants::-webkit-scrollbar-thumb:hover {
            background: #9cc49c;
        }

        /* prevent plant cards from overlapping with other UI */
        .plant-card {
            z-index: 3;
        }

        .plant-card {
            position: relative;
            width: 150px;
            background: linear-gradient(180deg, #fbfff9 0%, #f5fff2 100%);
            border-radius: 14px;
            padding: 12px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
            transition: all .2s cubic-bezier(0.34, 1.56, 0.64, 1);
            overflow: visible;
            border: 1px solid rgba(45, 106, 79, 0.08);
        }

        .plant-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 20px 40px rgba(20, 80, 40, 0.12);
            border-color: rgba(45, 106, 79, 0.2);
        }

        .plant-card img {
            width: 100%;
            height: 160px;
            /* Increased from 140px to 160px for better flower visibility */
            object-fit: cover;
            border-radius: 8px;
            box-shadow: inset 0 -6px 18px rgba(255, 255, 255, 0.25);
            flex-shrink: 0;
            /* Prevent image from shrinking */
        }

        .plant-name {
            font-weight: 600;
            color: #134a2d
        }

        .plant-meta {
            font-size: 12px;
            color: var(--muted)
        }

        /* ensure any remaining references to .plant-manage inherit the compact circular style */
        /* high-specificity rule to ensure the manage control does not stretch vertically
           and is confined to a circular area in the top-right of the card */
        .plant-card .plant-manage {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 34px;
            height: 34px;
            min-width: 34px;
            min-height: 34px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.92);
            border-radius: 50%;
            padding: 0;
            font-size: 16px;
            line-height: 1;
            cursor: pointer;
            color: var(--muted);
            border: 1px solid rgba(20, 50, 20, 0.06);
            box-shadow: 0 6px 14px rgba(10, 30, 18, 0.06);
            overflow: hidden;
            white-space: nowrap;
            z-index: 6;
        }

        .plant-card .plant-manage:hover {
            transform: translateY(-2px);
            background: rgba(255, 255, 255, 0.98);
            box-shadow: 0 8px 18px rgba(10, 30, 18, 0.08);
        }

        .plant-card .plant-manage:focus-visible {
            outline: 2px solid rgba(34, 139, 34, 0.35);
            outline-offset: 2px;
        }

        .plant-card .plant-manage svg {
            color: var(--muted);
        }

        .plant-card .plant-manage:hover svg {
            color: var(--accent);
        }

        .plant-manage-overlay {
            position: absolute;
            top: 36px;
            right: 8px;
            width: 320px;
            max-width: calc(100% - 16px);
            background: linear-gradient(180deg, #ffffff, #fbfff9);
            border-radius: 12px;
            padding: 10px;
            box-shadow: 0 20px 50px rgba(12, 40, 20, 0.18);
            z-index: 30;
        }

        .plant-manage-overlay .manage-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 10px;
        }

        .plant-manage-overlay .manage-title {
            font-weight: 600;
            color: #133a27
        }

        .plant-manage-overlay .manage-add {
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            color: #fff;
            padding: 6px 8px;
            border-radius: 8px;
            cursor: pointer;
            border: none;
            box-shadow: 0 8px 18px rgba(45, 106, 79, 0.12)
        }

        .plant-manage-overlay .thumb-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .plant-manage-overlay .thumb {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            background: #eef9ef
        }

        .plant-manage-overlay .thumb img {
            width: 100%;
            height: 72px;
            object-fit: cover;
            display: block
        }

        .plant-manage-overlay .del-icon {
            position: absolute;
            top: 6px;
            right: 6px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: none;
        }

        /* centered modal for manage UI */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(10, 20, 12, 0.45);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 60
        }

        .modal {
            background: #fff;
            border-radius: 12px;
            padding: 14px;
            width: 520px;
            max-width: 94%;
            box-shadow: 0 20px 50px rgba(6, 20, 12, 0.25)
        }

        .modal .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 12px
        }

        .modal .modal-title {
            font-weight: 700;
            color: #113a28
        }

        .modal .modal-actions {
            display: flex;
            gap: 8px;
            align-items: center
        }

        .modal .gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            width: 100%;
        }

        .modal .gallery .item {
            position: relative;
            border-radius: 10px;
            overflow: hidden;
            background: #f9f9f9;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal .gallery img {
            max-width: 95%;
            max-height: 95%;
            object-fit: contain;
            display: block;
            background: transparent;
        }

        .modal .delete-btn {
            position: absolute;
            top: 6px;
            right: 6px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            width: 34px;
            height: 34px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            cursor: pointer;
            z-index: 4;
            /* ensure it sits above image */
        }

        /* small delete button used in manage rows */
        .delete-small {
            background: transparent;
            border: 1px solid rgba(0, 0, 0, 0.06);
            color: var(--muted);
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
        }

        /* manage-row: compact grid for manage panel rows */
        #managePhotosContainer .manage-row {
            display: grid;
            grid-template-columns: 64px 1fr auto;
            gap: 12px;
            align-items: center;
            padding: 6px 8px;
            border-bottom: 1px solid rgba(6, 30, 18, 0.04);
        }

        #managePhotosContainer .manage-row img {
            width: 64px;
            height: 48px;
            object-fit: cover;
            border-radius: 6px
        }

        /* Gallery container for photos - allow horizontal scrolling on small screens */
        #managePhotosContainer {
            max-height: 400px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        #managePhotosContainer .gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
            width: 100%;
        }

        #managePhotosContainer .gallery .item img {
            width: 100%;
            height: 120px;
            object-fit: cover;
            border-radius: 8px;
        }

        .modal .empty {
            padding: 24px;
            text-align: center;
            color: var(--muted)
        }

        /* tiny confirm dialog */
        .confirm-dialog {
            background: #fff;
            padding: 14px;
            border-radius: 10px;
            width: 340px;
            max-width: 90%;
            box-shadow: 0 18px 40px rgba(6, 20, 12, 0.22)
        }

        .confirm-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 12px
        }


        .chat {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }

        /* make the right column scroll independently and stay above background */
        .grid>.panel:last-child {
            overflow: hidden;
            height: 100%;
        }

        .messages {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0.5));
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            background: linear-gradient(180deg, rgba(250, 255, 250, 0.6), rgba(248, 255, 248, 0.4));
            border-radius: 10px;
            min-height: 0;
        }

        .messages::-webkit-scrollbar {
            width: 7px;
        }

        .messages::-webkit-scrollbar-track {
            background: rgba(180, 200, 180, 0.08);
            border-radius: 4px;
        }

        .messages::-webkit-scrollbar-thumb {
            background: #a0d4a0;
            border-radius: 4px;
        }

        .messages::-webkit-scrollbar-thumb:hover {
            background: #9cc49c;
        }

        .msg {
            max-width: 78%;
            padding: 12px 14px;
            border-radius: 14px;
            background: linear-gradient(135deg, #f0fdf4, #f0fff3);
            box-shadow: 0 4px 12px rgba(20, 80, 40, 0.06);
            word-wrap: break-word;
            line-height: 1.5;
        }

        .msg.user {
            align-self: flex-end;
            background: linear-gradient(135deg, #dbeafe, #e6f0ff);
            box-shadow: 0 4px 12px rgba(30, 58, 138, 0.06);
        }

        .msg .meta {
            font-size: 12px;
            color: var(--muted);
            margin-top: 8px
        }

        .composer {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 12px;
            border-top: 1px solid #e6f3ea;
            background: rgba(255, 255, 255, 0.4);
        }

        /* ensure composer stays at the bottom of the chat panel */
        .panel.chat {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .panel.chat .messages {
            flex: 1 1 auto;
        }

        .panel.chat .composer {
            flex: 0 0 auto;
        }

        #chatHeader {
            margin-bottom: 16px;
        }

        /* upload panel becomes a centered modal when expanded */
        #uploadPanel {
            display: none;
        }

        #uploadPanel.expanded {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(10, 20, 12, 0.45);
            z-index: 80;
        }

        #uploadPanel .upload-card {
            width: 480px;
            max-width: calc(100% - 20px);
            box-shadow: 0 20px 50px rgba(6, 20, 12, 0.25);
        }

        /* upload progress bar */
        .upload-progress {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-top: 12px
        }

        .progress-bar-bg {
            flex: 1;
            background: rgba(0, 0, 0, 0.06);
            height: 10px;
            border-radius: 6px;
            overflow: hidden
        }

        .progress-bar-fill {
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            height: 100%;
            width: 0%;
            transition: width 200ms linear
        }

        #uploadProgressText {
            width: 48px;
            text-align: right;
            font-size: 13px;
            color: var(--muted)
        }

        /* Responsive: compact modal on small devices */
        @media (max-width: 640px) {
            #uploadPanel.expanded {
                align-items: center;
                justify-content: center;
                padding: 4px;
            }

            #uploadPanel .modal {
                width: 75%;
                max-width: 260px;
                height: auto;
                max-height: 85vh;
                border-radius: 12px;
                padding: 12px;
                box-sizing: border-box;
                background: linear-gradient(135deg, #ffffff 0%, #f9fdfb 100%);
            }

            #uploadPanel .upload-card {
                width: 100%;
                height: auto;
                max-height: none;
                display: flex;
                flex-direction: column;
                gap: 8px;
                overflow: auto;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            }

            .file-area {
                width: 100%;
                height: 100px;
                border-radius: 10px;
                border: 2px dashed rgba(45, 106, 79, 0.2);
            }

            .file-area:hover {
                background: linear-gradient(180deg, #f0faf4, #f8fff9);
                border-color: rgba(45, 106, 79, 0.3);
            }

            .upload-fields {
                padding: 2px 0;
                display: flex;
                flex-direction: column;
                gap: 6px;
            }

            .upload-fields input {
                padding: 6px 8px;
                font-size: 12px;
                border-radius: 6px;
            }

            #uploadPanel button {
                padding: 8px 12px;
                font-size: 12px;
                border-radius: 6px;
            }
        }

        .small {
            font-size: 13px;
            color: var(--muted)
        }

        #chatMeta {
            margin-bottom: 16px;
        }

        .empty {
            color: var(--muted);
            text-align: center;
            padding: 24px
        }

        /* message animation and typing dots */
        .msg {
            animation: fadeIn .28s ease both
        }

        /* responsive: stack panels on small screens */
        @media (max-width: 920px) {
            .grid {
                grid-template-columns: 1fr;
            }

            .hero {
                gap: 4px;
                /* Reduced from 8px */
                margin-bottom: 12px;
                /* Reduced margin */
            }

            .container {
                padding: 14px
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(6px)
            }

            to {
                opacity: 1;
                transform: none
            }
        }

        .dot {
            width: 8px;
            height: 8px;
            background: #9bd39b;
            border-radius: 50%;
            opacity: 0.6;
            animation: blink 1s infinite
        }

        .dot:nth-child(2) {
            animation-delay: 0.15s
        }

        .dot:nth-child(3) {
            animation-delay: 0.3s
        }

        @keyframes blink {

            0%,
            80%,
            100% {
                transform: translateY(0);
                opacity: 0.35
            }

            40% {
                transform: translateY(-4px);
                opacity: 1
            }
        }

        /* Responsive: stack on small screens */
        @media (max-width:880px) {
            .grid {
                grid-template-columns: 1fr;
            }

            .chat {
                order: 2;
                min-height: 25vh;
            }

            .panel {
                padding: 14px
            }

            .logo {
                padding: 5px 9px;
                /* Reduced padding for tablets */
                font-size: 0.85rem;
                /* Reduced font size */
            }

            .plant-card {
                width: 48%;
                /* Increased from 44% to 48% for better visibility */
                min-width: 160px;
                /* Ensure minimum width for image visibility */
            }

            .plant-card img {
                height: 180px;
                /* Increased height for tablet to show more of flowers */
            }

            .messages {
                min-height: 0;
            }
        }

        @media (max-width: 768px) and (min-width: 641px) {

            /* Medium tablets - ensure cards are wide enough */
            .plant-card {
                width: 47%;
                min-width: 170px;
            }

            .plant-card img {
                height: 190px;
                /* Even taller for medium tablets to show full flowers */
            }
        }

        @media (max-width: 640px) {
            .chat {
                min-height: 20vh;
            }
        }

        @media (max-width: 420px) {
            .chat {
                min-height: 18vh;
            }

            .messages {
                padding: 6px;
                gap: 6px;
            }

            .composer {
                padding: 6px;
                gap: 4px;
            }

            .composer input,
            .composer button {
                font-size: 9px;
                min-height: 28px;
                padding: 3px 6px;
            }

            #chatHeader {
                gap: 6px !important;
            }

            #chatTitle {
                font-size: 13px !important;
            }
        }

        @media (max-width:420px) {
            body {
                padding: 12px
            }

            .plant-card {
                width: 100%;
                flex-direction: row;
                gap: 12px;
                align-items: center
            }

            .plant-card img {
                width: 90px;
                /* Increased from 84px for better visibility */
                height: 70px;
                /* Increased from 64px for better visibility */
                object-fit: cover;
                /* Ensure proper image display */
            }
        }

        /* Dark mode styles */
        body.dark-mode {
            --bg: #1a1a1a;
            --card: #2d2d2d;
            --accent: #4ade80;
            --accent-2: #86efac;
            --muted: #a0a0a0;
            --glass: rgba(45, 45, 45, 0.6);
            color: #e0e0e0;
            background-color: #1a1a1a;
        }

        body.dark-mode .bg-overlay {
            background: rgba(0, 0, 0, 0.3);
        }

        body.dark-mode .panel,
        body.dark-mode .plants,
        body.dark-mode .chat {
            background-color: #2d2d2d;
            color: #e0e0e0;
            border-color: #444;
        }

        body.dark-mode input,
        body.dark-mode textarea,
        body.dark-mode select {
            background-color: #333;
            color: #e0e0e0;
            border-color: #555;
        }

        body.dark-mode button {
            background-color: #444;
            color: #e0e0e0;
            border-color: #666;
        }

        body.dark-mode button:hover {
            background-color: #555;
        }

        body.dark-mode .health-dashboard {
            background: #333 !important;
        }

        body.dark-mode #compareModal {
            background-color: rgba(0, 0, 0, 0.9);
        }

        body.dark-mode #compareModal>div {
            background-color: #2d2d2d;
        }

        body.dark-mode .msg {
            background-color: #333;
            color: #e0e0e0;
        }

        body.dark-mode .message-user {
            background-color: #1f6b32;
        }

        body.dark-mode .message-plant {
            background-color: #264f37;
        }

        body.dark-mode #historyContainer,
        body.dark-mode #managePhotosContainer {
            background: #333 !important;
        }

        /* Health status colors */
        .health-thriving {
            background-color: #86efac !important;
            color: #1a1a1a !important;
        }

        .health-stable {
            background-color: #87ceeb !important;
            color: #1a1a1a !important;
        }

        .health-stressed {
            background-color: #fca5a5 !important;
            color: #1a1a1a !important;
        }

        .growth-chart-container {
            margin-top: 15px;
            padding: 15px;
            background: var(--card);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .growth-chart-container h4 {
            margin: 0 0 12px 0;
            font-size: 14px;
            font-weight: 600;
            color: var(--accent);
        }

        .milestone-celebration {
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            border-radius: 12px;
            margin: 15px 0;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .milestone-celebration .emoji {
            font-size: 40px;
            margin-bottom: 10px;
        }

        .compare-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .compare-modal.show {
            display: flex;
        }

        .compare-modal-content {
            background: var(--card);
            padding: 24px;
            border-radius: 12px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .compare-modal-close {
            float: right;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--muted);
        }

        .compare-modal-close:hover {
            color: var(--accent);
        }

        .compare-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }

        .compare-grid img {
            width: 100%;
            border-radius: 8px;
            max-height: 400px;
            object-fit: cover;
        }

        .compare-info {
            font-size: 12px;
            color: var(--muted);
            margin-top: 8px;
        }

        .analytics-container {
            display: none;
            padding: 20px;
        }

        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .analytics-card {
            padding: 15px;
            background: var(--card);
            border-radius: 8px;
            border: 1px solid var(--muted);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .analytics-card h4 {
            margin: 0;
            color: var(--accent);
        }

        .analytics-card .stat {
            font-size: 13px;
            line-height: 1.8;
            color: var(--muted);
            margin-top: 8px;
        }

        .analytics-card .champion {
            color: #ffd700;
            font-weight: bold;
            margin-top: 10px;
        }

        /* Hide technical UI elements to keep chat experience natural and focused */
        #toggleHistoryBtn,
        #compareBtn {
            display: none !important;
        }

        /* Voice Button Styles */
        .composer #voiceBtn {
            background: linear-gradient(135deg, #52b788, #40916c);
            width: 44px;
            height: 40px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(45, 106, 79, 0.15);
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            outline: none;
            position: relative;
            font-size: 20px;
            line-height: 1;
        }

        .composer #voiceBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(45, 106, 79, 0.25);
            background: linear-gradient(135deg, #52b788, #2d6a4f);
        }

        .composer #voiceBtn:active {
            transform: translateY(0px);
        }

        .composer #voiceBtn.listening {
            background: linear-gradient(135deg, #ff6b6b, #ff4757);
            animation: pulse 1s infinite;
            box-shadow: 0 4px 12px rgba(255, 71, 87, 0.3);
        }

        .composer #voiceBtn.listening:hover {
            background: linear-gradient(135deg, #ff5252, #ff3838);
        }

        @keyframes pulse {

            0%,
            100% {
                box-shadow: 0 4px 12px rgba(255, 71, 87, 0.3);
            }

            50% {
                box-shadow: 0 4px 20px rgba(255, 71, 87, 0.6);
            }
        }
    </style>
</head>

<body>
    <div class="bg-overlay" aria-hidden></div>
    <div id="debugLog"
        style="position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.8); color: #0f0; font-size: 10px; padding: 8px; border-radius: 4px; max-width: 200px; max-height: 150px; overflow-y: auto; font-family: monospace; z-index: 9999; display: none; line-height: 1.2;">
    </div>
    <div class="container">
        <header class="hero">
            <div class="logo">ðŸŒ¿ LB</div>
            <h1>My Soulmates</h1>
            <p>Mine Only</p>
            <div style="position: absolute; top: 30px; right: 30px; z-index: 100;">
                <select id="langSelector"
                    style="padding: 8px 14px; border-radius: 6px; border: 1px solid #52b788; background: white; cursor: pointer; font-size: 13px; font-weight: 500; white-space: nowrap;">
                    <option value="en">en</option>
                    <option value="kn">à²•</option>
                </select>
            </div>
        </header>

        <div class="grid">
            <div class="panel">
                <div style="display:flex; align-items:center; gap:12px; flex-wrap:wrap;">
                    <button id="tab-plants" class="ghost small active">Plants</button>
                    <button id="tab-flowers" class="ghost small">Flowers</button>
                    <input id="searchBox" type="text" placeholder="ðŸ” Search..." style="flex:1; min-width:120px;">
                    <button id="openUploadBtn" class="ghost">Add photo</button>
                </div>

                <!-- Owner Filter Buttons -->
                <div
                    style="display:flex; align-items:center; gap:8px; margin-top:12px; flex-wrap:wrap; padding-bottom:10px; border-bottom:1px solid #e0e0e0;">
                    <span style="font-size:12px; color:var(--muted); font-weight:500;">Filter:</span>
                    <button id="filter-all" class="ghost small active" style="font-size:12px; padding:4px 10px;">All
                        Plants</button>
                    <button id="filter-mother" class="ghost small" style="font-size:12px; padding:4px 10px;">ðŸ‘©â€ðŸ¦°
                        Amma</button>
                    <button id="filter-friend" class="ghost small" style="font-size:12px; padding:4px 10px;">ðŸ‘§
                        Ammulu</button>
                </div>

                <!-- uploadPanel removed from inline layout and rendered as modal at end of body -->

                <div style="margin-top:12px">
                    <div id="plants" class="plants"></div>
                </div>
            </div>

            <div class="panel chat" id="chatPanel">
                <div id="chatHeader" style="display:flex; align-items:center; justify-content:space-between; gap:12px">
                    <div>
                        <h3 id="chatTitle" style="margin:0; font-size:14px;">Select a plant</h3>
                    </div>
                    <div style="display:flex; gap:8px; align-items:center">
                        <button id="toggleHistoryBtn" class="ghost small" style="display:none">Show history</button>
                        <button id="compareBtn" class="ghost small" style="display:none">Compare with previous</button>
                        <!-- manage moved to plant cards on the left for clarity -->
                    </div>
                </div>

                <!-- Health Dashboard - Hidden by default to keep focus on chat -->
                <div id="healthDashboard" class="health-dashboard"
                    style="padding: 15px; background: var(--card); border-radius: 8px; margin-bottom: 15px; display: none; box-shadow: 0 2px 8px rgba(0,0,0,0.06);">
                    <h4 style="margin: 0 0 10px 0; color: var(--accent); font-size: 14px;">Plant Vitals</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 13px;">
                        <div>
                            <strong>Status:</strong>
                            <span id="healthStatus"
                                style="display: inline-block; margin-left: 5px; padding: 3px 10px; border-radius: 4px; background: #e0f2fe; font-size: 12px;">stable</span>
                        </div>
                        <div>
                            <strong>Care Score:</strong>
                            <span id="careScore" style="font-weight: 600;">50/100</span>
                        </div>
                        <div>
                            <strong>Days Since Watering:</strong>
                            <span id="daysSinceWatering" style="color: var(--muted);">unknown</span>
                        </div>
                        <div>
                            <strong>Care Style:</strong>
                            <span id="careStyle" style="color: var(--muted);">unknown</span>
                        </div>
                    </div>
                </div>

                <!-- Growth Timeline Chart -->
                <div id="growthChartContainer" class="growth-chart-container" style="display: none;">
                    <h4>Growth Timeline</h4>
                    <canvas id="growthCanvas" width="400" height="200"></canvas>
                </div>

                <div id="messages" class="messages">
                    <div class="empty">ðŸŒ±</div>
                    <div id="typingIndicator" style="display:none; margin-top:6px;">
                        <div class="msg" style="max-width:160px; background:transparent; box-shadow:none">
                            <div style="display:flex; gap:6px; align-items:center">
                                <div class="dot"></div>
                                <div class="dot"></div>
                                <div class="dot"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- hidden panels for history and photo management -->
                <div id="historyContainer"
                    style="display:none; margin-top:10px; padding:10px; border-radius:8px; background: rgba(255,255,255,0.9); box-shadow:0 8px 20px rgba(0,0,0,0.06);">
                </div>
                <div id="managePhotosContainer"
                    style="display:none; margin-top:10px; padding:10px; border-radius:8px; background: rgba(255,255,255,0.95); box-shadow:0 8px 20px rgba(0,0,0,0.06);">
                </div>

                <!-- manage photos control moved into header for a cleaner look -->

                <div class="composer">
                    <input id="replyText" placeholder="Type something kind..." style="flex:1" />
                    <button id="voiceBtn" title="Speak to plant (click to record)"></button>
                    <button id="sendReply" title="Send message">ðŸ’¬</button>
                    <button id="speakLast" title="Replay plant's voice">ðŸ”Š</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Prevent Chrome from showing offline error page
        // Check if we're actually online and server is reachable
        window.addEventListener('online', () => {
            console.log('Browser is online');
            // If we were on an error page, try to reload
            if (window.location.href.includes('chrome-error://')) {
                window.location.href = 'http://localhost:3000';
            }
        });

        window.addEventListener('offline', () => {
            console.warn('Browser detected offline mode - but this might be a false positive');
        });

        // On page load, check if we're stuck on error page
        if (window.location.href.includes('chrome-error://')) {
            console.log('Detected Chrome error page, redirecting to localhost:3000');
            setTimeout(() => {
                window.location.href = 'http://localhost:3000';
            }, 100);
        }

        // Debug logging to screen (for mobile testing)
        const debugLog = document.getElementById('debugLog');
        const originalLog = console.log;
        const originalError = console.error;
        let logMessages = [];

        function addDebugLog(msg) {
            logMessages.push(msg);
            if (logMessages.length > 20) logMessages.shift();
            debugLog.innerHTML = logMessages.join('<br>');
            debugLog.style.display = 'none';  // Keep hidden - disable debug display
        }

        console.log = function (...args) {
            originalLog(...args);
            // Don't display logs on page - commented out
            // addDebugLog(args.join(' '));
        };

        console.error = function (...args) {
            originalError(...args);
            // Don't display errors on page - commented out
            // addDebugLog('âŒ ' + args.join(' '));
        };

        // Don't show debug log on mobile - keep hidden
        debugLog.style.display = 'none';

        // ============================================================================
        // LANGUAGE SYSTEM - English & Kannada
        // ============================================================================

        let currentLanguage = localStorage.getItem('appLanguage') || 'en';
        let isListening = false;  // Declare early to avoid ReferenceError in updateUILanguage
        let currentOwnerFilter = 'all';  // Filter for owner: 'all', 'mother', 'friend'

        const translations = {
            en: {
                plants: 'Plants',
                flowers: 'Flowers',
                search: 'ðŸ” Search...',
                addPhoto: 'Add photo',
                typeSomething: 'Type something kind...',
                sendMessage: 'ðŸ’¬',
                replayVoice: 'ðŸ”Š',
                speakToPlant: 'Speak to plant (click to record)',
                listeningCancel: 'Listening... Click to cancel',
                noChat: 'Select a plant',
                noPhotos: 'No photos yet',
                uploadPhoto: 'Upload Photo',
                cancel: 'Cancel'
            },
            kn: {
                plants: 'à²¸à²¸à³à²¯à²—à²³à³',
                flowers: 'à²¹à³‚à²µà³à²—à²³à³',
                search: 'ðŸ” à²¹à³à²¡à³à²•à²¿...',
                addPhoto: 'à²«à³‹à²Ÿà³‹ à²¸à³‡à²°à²¿à²¸à²¿',
                typeSomething: 'à²¯à²¾à²µà³à²¦à³‹ à²¸à³à²‚à²¦à²°à²µà²¾à²—à²¿ à²Ÿà³ˆà²ªà³ à²®à²¾à²¡à²¿...',
                sendMessage: 'ðŸ’¬',
                replayVoice: 'ðŸ”Š',
                speakToPlant: 'à²¸à²¸à³à²¯à²•à³à²•à³† à²®à²¾à²¤à²¨à²¾à²¡à²¿ (à²°à³†à²•à²¾à²°à³à²¡à³ à²®à²¾à²¡à²²à³ à²•à³à²²à²¿à²•à³ à²®à²¾à²¡à²¿)',
                listeningCancel: 'à²•à³‡à²³à³à²¤à³à²¤à²¿à²¦à³†... à²°à²¦à³à²¦à³à²—à³Šà²³à²¿à²¸à²²à³ à²•à³à²²à²¿à²•à³ à²®à²¾à²¡à²¿',
                noChat: 'à²¸à²¸à³à²¯à²µà²¨à³à²¨à³ à²†à²¯à³à²•à³† à²®à²¾à²¡à²¿',
                noPhotos: 'à²‡à²¨à³à²¨à³‚ à²«à³‹à²Ÿà³‹ à²‡à²²à³à²²',
                uploadPhoto: 'à²«à³‹à²Ÿà³‹ à²…à²ªà³à²²à³‹à²¡à³ à²®à²¾à²¡à²¿',
                cancel: 'à²°à²¦à³à²¦à³à²—à³Šà²³à²¿à²¸à²¿'
            }
        };

        function t(key) {
            return translations[currentLanguage]?.[key] || translations.en[key];
        }

        function setLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('appLanguage', lang);

            // Update voice recognition language
            if (recognition) {
                recognition.lang = lang === 'kn' ? 'kn-IN' : 'en-US';
            }

            // Update UI elements
            updateUILanguage();
        }

        function updateUILanguage() {
            document.getElementById('tab-plants').textContent = t('plants');
            document.getElementById('tab-flowers').textContent = t('flowers');
            document.getElementById('searchBox').placeholder = t('search');
            document.getElementById('openUploadBtn').textContent = t('addPhoto');
            document.getElementById('replyText').placeholder = t('typeSomething');

            const voiceBtn = document.getElementById('voiceBtn');
            if (voiceBtn) {
                voiceBtn.title = isListening ? t('listeningCancel') : t('speakToPlant');
            }
        }

        // Setup language selector
        const langSelector = document.getElementById('langSelector');
        if (langSelector) {
            langSelector.value = currentLanguage;
            langSelector.addEventListener('change', (e) => {
                setLanguage(e.target.value);
            });
        }

        // Initialize UI with saved language
        updateUILanguage();

        // Helper: Detect if device is mobile
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        // Helper: Detect if device is Android specifically
        function isAndroid() {
            return /Android/i.test(navigator.userAgent);
        }

        // Audio permission system
        let audioPermissionGranted = localStorage.getItem('audioPermission');

        async function requestAudioPermission() {
            // If already decided, don't ask again
            if (audioPermissionGranted !== null) {
                return audioPermissionGranted === 'true';
            }

            // On desktop, allow audio without microphone permission
            if (!isMobile()) {
                audioPermissionGranted = 'true';
                localStorage.setItem('audioPermission', 'true');
                return true;
            }

            // On mobile, request microphone access to enable audio
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                stream.getTracks().forEach(track => track.stop());
                audioPermissionGranted = 'true';
                localStorage.setItem('audioPermission', 'true');
                return true;
            } catch (error) {
                audioPermissionGranted = 'false';
                localStorage.setItem('audioPermission', 'false');
                return false;
            }
        }

        // Request permission on page load
        requestAudioPermission().catch(err => { });

        // Helper: local conversation storage per plant
        function convKey(plantId) { return `conv_${plantId}` }
        function loadConv(plantId) { try { return JSON.parse(localStorage.getItem(convKey(plantId)) || '[]') } catch (e) { return [] } }
        function saveConv(plantId, arr) { localStorage.setItem(convKey(plantId), JSON.stringify(arr)) }

        let currentPlant = null;
        // id of image user selected to focus replies on (optional)
        let selectedImageId = null;

        // Typing indicator controls
        function showTyping() { const t = document.getElementById('typingIndicator'); if (t) t.style.display = 'block'; const msgs = document.getElementById('messages'); if (msgs) msgs.scrollTop = msgs.scrollHeight; }
        function hideTyping() { const t = document.getElementById('typingIndicator'); if (t) t.style.display = 'none'; }

        // Toast notification
        function showToast(message, type = 'info', duration = 3000) {
            let container = document.getElementById('toastContainer');
            if (!container) {
                container = document.createElement('div');
                container.id = 'toastContainer';
                container.style.cssText = 'position:fixed; top:20px; right:20px; z-index:10000; display:flex; flex-direction:column; gap:10px; pointer-events:none;';
                document.body.appendChild(container);
            }
            const toast = document.createElement('div');
            const bgColor = type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3';
            toast.style.cssText = `background:${bgColor}; color:white; padding:10px 16px; border-radius:4px; font-size:13px; box-shadow:0 2px 8px rgba(0,0,0,0.2); animation:slideIn 0.3s ease-out; pointer-events:auto; max-width:250px; word-wrap:break-word;`;
            toast.textContent = message;
            container.appendChild(toast);
            if (duration > 0) {
                setTimeout(() => {
                    toast.style.animation = 'slideOut 0.3s ease-out';
                    setTimeout(() => toast.remove(), 300);
                }, duration);
            }
        }
        if (!document.getElementById('toastStyles')) {
            const style = document.createElement('style');
            style.id = 'toastStyles';
            style.textContent = '@keyframes slideIn { from { transform: translateX(400px); opacity: 0; } to { transform: translateX(0); opacity: 1; } } @keyframes slideOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(400px); opacity: 0; } }';
            document.head.appendChild(style);
        }

        // Upload preview helpers
        const photoInput = document.getElementById('photo');
        const photoPreview = document.getElementById('photoPreview');
        const filePlaceholder = document.getElementById('filePlaceholder');
        const clearBtn = document.getElementById('clearPhoto');

        // Click on the visible file button opens hidden input. Stop propagation so the label
        // doesn't also trigger the native file picker (which would cause two prompts).
        // Use delegated handlers because the upload modal is appended after this script runs.
        document.addEventListener('click', (ev) => {
            try {
                const btn = ev.target.closest && ev.target.closest('.file-btn');
                if (btn) {
                    ev.preventDefault(); ev.stopPropagation();
                    const p = document.getElementById('photo');
                    if (p) p.click();
                }
                const clear = ev.target.closest && ev.target.closest('#clearPhoto');
                if (clear) {
                    ev.preventDefault(); ev.stopPropagation();
                    const p = document.getElementById('photo'); if (p) p.value = '';
                    const preview = document.getElementById('photoPreview'); if (preview) { preview.src = ''; preview.style.display = 'none'; }
                    const placeholder = document.getElementById('filePlaceholder'); if (placeholder) placeholder.style.display = 'block';
                }
            } catch (e) { }
        });

        // Listen for file input changes via delegation (input may be appended later)
        document.addEventListener('change', (ev) => {
            try {
                if (ev.target && ev.target.id === 'photo') {
                    const f = ev.target.files && ev.target.files[0];
                    if (!f) return;
                    const url = URL.createObjectURL(f);
                    const photoPreviewEl = document.getElementById('photoPreview');
                    const placeholderEl = document.getElementById('filePlaceholder');
                    if (photoPreviewEl) { photoPreviewEl.src = url; photoPreviewEl.style.display = 'block'; }
                    if (placeholderEl) placeholderEl.style.display = 'none';
                }
            } catch (e) { }
        });

        if (photoInput) {
            photoInput.addEventListener('change', (ev) => {
                const f = ev.target.files && ev.target.files[0];
                if (!f) return;
                const url = URL.createObjectURL(f);
                photoPreview.src = url; photoPreview.style.display = 'block'; filePlaceholder.style.display = 'none';
            });
        }

        // Drag-and-drop support on file-area
        const fileArea = document.querySelector('.file-area');
        if (fileArea) {
            ['dragenter', 'dragover'].forEach(evt => fileArea.addEventListener(evt, (e) => { e.preventDefault(); e.stopPropagation(); fileArea.classList.add('drag-over'); }));
            ['dragleave', 'drop'].forEach(evt => fileArea.addEventListener(evt, (e) => { e.preventDefault(); e.stopPropagation(); fileArea.classList.remove('drag-over'); }));
            fileArea.addEventListener('drop', (e) => {
                const f = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
                if (!f) return;
                if (photoInput) { photoInput.files = e.dataTransfer.files; }
                const url = URL.createObjectURL(f);
                if (photoPreview) { photoPreview.src = url; photoPreview.style.display = 'block'; }
                if (filePlaceholder) filePlaceholder.style.display = 'none';
            });
        }

        // Resize an image file in the browser to a max dimension (preserving aspect ratio)
        async function resizeImageFile(file, maxDim = 1024) {
            if (!file || !file.type.startsWith('image/')) return file;
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    let { width, height } = img;
                    if (width <= maxDim && height <= maxDim) return resolve(file);
                    const ratio = width / height;
                    if (width > height) {
                        width = maxDim; height = Math.round(maxDim / ratio);
                    } else {
                        height = maxDim; width = Math.round(maxDim * ratio);
                    }
                    const canvas = document.createElement('canvas');
                    canvas.width = width; canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    canvas.toBlob((blob) => {
                        if (!blob) return resolve(file);
                        const newFile = new File([blob], file.name, { type: blob.type });
                        resolve(newFile);
                    }, file.type || 'image/jpeg', 0.85);
                };
                img.onerror = (e) => reject(e);
                img.src = URL.createObjectURL(file);
            });
        }

        if (clearBtn) clearBtn.addEventListener('click', () => {
            if (photoInput) { photoInput.value = ''; }
            if (photoPreview) { photoPreview.src = ''; photoPreview.style.display = 'none'; }
            if (filePlaceholder) filePlaceholder.style.display = 'block';
        });

        // uploadPanel and close button are appended later in the DOM; query them when needed
        const openUploadBtn = document.getElementById('openUploadBtn');
        function openUpload() {
            console.log('openUpload() called');
            const uploadPanel = document.getElementById('uploadPanel');
            if (!uploadPanel) { console.warn('uploadPanel not found'); return; }
            // ensure panel is visible even if CSS gets overridden elsewhere
            uploadPanel.style.display = 'flex';
            uploadPanel.setAttribute('aria-hidden', 'false');
            uploadPanel.classList.remove('collapsed');
            uploadPanel.classList.add('expanded');
            // clear any previous error
            const errorMsg = document.getElementById('uploadError');
            if (errorMsg) errorMsg.remove();
            // focus first focusable control inside modal
            const focusable = uploadPanel.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
            if (focusable) try { focusable.focus(); } catch (e) { }
            // enable focus trap
            enableUploadFocusTrap();
        }
        function closeUpload() {
            console.log('closeUpload() called');
            const uploadPanel = document.getElementById('uploadPanel');
            if (!uploadPanel) return;
            uploadPanel.classList.remove('expanded');
            uploadPanel.classList.add('collapsed');
            // also remove inline display override so CSS can control it
            uploadPanel.style.display = '';
            uploadPanel.setAttribute('aria-hidden', 'true');
            // restore focus to Add photo button
            try { document.getElementById('openUploadBtn')?.focus(); } catch (e) { }
            // disable focus trap
            disableUploadFocusTrap();
        }

        // Helper to reset form to initial state
        function resetUploadForm() {
            try {
                const photoInput = document.getElementById('photo');
                const photoPreview = document.getElementById('photoPreview');
                const filePlaceholder = document.getElementById('filePlaceholder');
                const nicknameInput = document.getElementById('nickname');

                if (photoInput) photoInput.value = '';
                if (photoPreview) { photoPreview.src = ''; photoPreview.style.display = 'none'; }
                if (filePlaceholder) filePlaceholder.style.display = 'block';
                if (nicknameInput) nicknameInput.value = '';
            } catch (e) { console.warn('resetUploadForm error', e); }
        }

        if (openUploadBtn) {
            openUploadBtn.addEventListener('click', (ev) => { ev.preventDefault(); console.log('openUploadBtn clicked'); resetUploadForm(); openUpload(); });
        } else {
            // fallback: delegated listener in case button is rendered later or replaced
            document.addEventListener('click', (ev) => {
                try {
                    const t = ev.target;
                    if (!t) return;
                    if (t.id === 'openUploadBtn' || t.closest && t.closest('#openUploadBtn')) { ev.preventDefault(); console.log('delegated openUpload click'); resetUploadForm(); openUpload(); }
                } catch (e) { }
            });
        }
        // delegate close button clicks (close button is inside modal appended later)
        document.addEventListener('click', (ev) => {
            try {
                const t = ev.target;
                if (t && t.id === 'closeUploadBtn') { ev.preventDefault(); closeUpload(); }
            } catch (e) { }
        });

        // Close upload modal when clicking outside the modal or pressing ESC
        document.addEventListener('click', (ev) => {
            try {
                const up = document.getElementById('uploadPanel');
                if (!up) return;
                if (!up.classList.contains('expanded')) return;
                // if click target is the panel backdrop (uploadPanel itself) then close
                if (ev.target === up) closeUpload();
            } catch (e) { }
        }, true);

        document.addEventListener('keydown', (ev) => {
            if (ev.key === 'Escape') {
                try { const up = document.getElementById('uploadPanel'); if (up && up.classList.contains('expanded')) closeUpload(); } catch (e) { }
            }
        });

        // Focus trap implementation
        let _uploadTrapHandler = null;
        function enableUploadFocusTrap() {
            const panel = document.getElementById('uploadPanel');
            if (!panel) return;
            const focusableSelectors = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, [tabindex]:not([tabindex="-1"])';
            const nodes = Array.from(panel.querySelectorAll(focusableSelectors)).filter(n => n.offsetParent !== null);
            if (!nodes.length) return;
            const first = nodes[0];
            const last = nodes[nodes.length - 1];
            _uploadTrapHandler = function (e) {
                if (e.key !== 'Tab') return;
                if (e.shiftKey) {
                    if (document.activeElement === first) { e.preventDefault(); last.focus(); }
                } else {
                    if (document.activeElement === last) { e.preventDefault(); first.focus(); }
                }
            };
            document.addEventListener('keydown', _uploadTrapHandler);
        }
        function disableUploadFocusTrap() {
            if (_uploadTrapHandler) { document.removeEventListener('keydown', _uploadTrapHandler); _uploadTrapHandler = null; }
        }

        async function loadPlants() {
            try {
                const res = await fetchWithFallback('/plants');
                const data = await res.json();
                console.log('Loaded plant data:', data.length, 'plants');
                const container = document.getElementById('plants');
                container.innerHTML = '';

                // Update filter label when loading plants
                const filterAll = document.getElementById('filter-all');
                if (filterAll && activeTab === 'plants') {
                    filterAll.textContent = 'All Plants';
                }

                // (attach select population moved later to attachSubjectSelect population below)
                // hide plants that have no images to avoid empty placeholders
                let visible = (data || []).filter(p => p.images && p.images.length > 0);

                // Apply owner filter
                if (currentOwnerFilter !== 'all') {
                    visible = visible.filter(p => (p.owner || null) === currentOwnerFilter);
                }

                console.log('Visible plants:', visible.length);
                if (!visible.length) container.innerHTML = '<div class="small">No plants yet â€” upload a photo to add one.</div>';
                visible.forEach(p => {
                    const card = document.createElement('div'); card.className = 'plant-card';
                    card.dataset.id = p.id;
                    // ensure we can absolutely position the manage button
                    card.style.position = 'relative';
                    // ...existing code...
                    const img = document.createElement('img');
                    const last = p.images[p.images.length - 1];
                    img.src = last ? getImageUrl(last.filename) + '?t=' + Date.now() : 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="140"><rect width="100%" height="100%" fill="%23eef9ef"/></svg>';
                    card.appendChild(img);
                    const name = document.createElement('div'); name.className = 'plant-name'; name.textContent = p.nickname || p.species || 'Unknown';
                    card.appendChild(name);
                    const meta = document.createElement('div'); meta.className = 'small'; meta.textContent = p.images.length + ' photos';
                    card.appendChild(meta);

                    // per-card manage button (clicking it opens the manage panel for this plant only)
                    const manageBtn = document.createElement('button');
                    manageBtn.className = 'plant-manage';
                    manageBtn.type = 'button';
                    manageBtn.title = 'Manage photos';
                    manageBtn.setAttribute('aria-label', 'Manage photos');
                    manageBtn.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden>
                        <circle cx="5" cy="12" r="1.6" fill="currentColor" />
                        <circle cx="12" cy="12" r="1.6" fill="currentColor" />
                        <circle cx="19" cy="12" r="1.6" fill="currentColor" />
                    </svg>
                `;
                    manageBtn.addEventListener('click', (e) => { e.stopPropagation(); showManageModal(Object.assign({ _type: 'plant' }, p)); });
                    card.appendChild(manageBtn);

                    card.onclick = () => openChat(p.id);
                    container.appendChild(card);
                });
                // If the currently-open plant no longer has images (was pruned from visible), clear the chat
                if (currentPlant && !visible.some(p => p.id === currentPlant.id)) {
                    currentPlant = null;
                    const msgs = document.getElementById('messages'); if (msgs) msgs.innerHTML = '<div class="empty">ðŸŒ±</div>';
                    document.getElementById('chatTitle').textContent = 'Select a plant';
                    const manageBtnEl = document.getElementById('managePhotosBtn'); if (manageBtnEl) manageBtnEl.disabled = true;
                    const historyContainer = document.getElementById('historyContainer'); if (historyContainer) historyContainer.style.display = 'none';
                    const managePhotosContainer = document.getElementById('managePhotosContainer'); if (managePhotosContainer) managePhotosContainer.style.display = 'none';
                }
                // enable/disable manage button depending on whether any plants exist
                const _manageBtn = document.getElementById('managePhotosBtn');
                if (_manageBtn) _manageBtn.disabled = (data.length === 0);

                // populate attachSubjectSelect with plants and flowers
                try {
                    const sel = document.getElementById('attachSubjectSelect');
                    if (sel) {
                        sel.innerHTML = '<option value="new:plant">Upload new plant</option><option value="new:flower">Upload new flower</option>';
                        (data || []).forEach(p => {
                            const opt = document.createElement('option');
                            opt.value = `plant:${p.id}`;
                            opt.textContent = (p.nickname || p.species || 'Plant') + ` â€” ${p.images ? p.images.length : 0} photos`;
                            sel.appendChild(opt);
                        });
                        // also add flowers
                        const fres = await fetchWithFallback('/flowers');
                        const fdata = await fres.json();
                        (fdata || []).forEach(f => {
                            const opt = document.createElement('option');
                            opt.value = `flower:${f.id}`;
                            opt.textContent = (f.nickname || f.species || 'Flower') + ` â€” ${f.images ? f.images.length : 0} photos`;
                            sel.appendChild(opt);
                        });
                    }
                } catch (e) { }
            } catch (e) {
                console.error('Failed to load plants:', e);
                const container = document.getElementById('plants');
                if (container) {
                    container.innerHTML = '<div class="small" style="color: #d32f2f;">Failed to load plants. Please check your connection.</div>';
                }
            }
            // Ensure label is correct after loading
            if (activeTab === 'plants') {
                const filterAll = document.getElementById('filter-all');
                if (filterAll) filterAll.textContent = 'All Plants';
            }
        }

        // Flowers loader re-uses the same rendering as plants but fetches /flowers
        async function loadFlowers() {
            try {
                const res = await fetchWithFallback('/flowers');
                const data = await res.json();
                const container = document.getElementById('plants');
                container.innerHTML = '';

                // Update filter label when loading flowers
                const filterAll = document.getElementById('filter-all');
                if (filterAll && activeTab === 'flowers') {
                    filterAll.textContent = 'All Flowers';
                }

                let visible = (data || []).filter(p => p.images && p.images.length > 0);

                // Apply owner filter
                if (currentOwnerFilter !== 'all') {
                    visible = visible.filter(p => (p.owner || null) === currentOwnerFilter);
                }

                if (!visible.length) container.innerHTML = '<div class="small">No flowers yet â€” add one to chat with it.</div>';
                visible.forEach(p => {
                    const card = document.createElement('div'); card.className = 'plant-card';
                    card.dataset.id = p.id;
                    card.style.position = 'relative';
                    // (no visual 'Flower' badge â€” rendering is kept minimal)
                    const img = document.createElement('img');
                    const last = p.images && p.images.length ? p.images[p.images.length - 1] : null;
                    img.src = last ? `/uploads/${last.filename}?t=${Date.now()}` : 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="140"><rect width="100%" height="100%" fill="%23fff0f6"/></svg>';
                    card.appendChild(img);
                    const name = document.createElement('div'); name.className = 'plant-name'; name.textContent = p.nickname || p.species || 'Unknown';
                    card.appendChild(name);
                    const meta = document.createElement('div'); meta.className = 'small'; meta.textContent = (p.images && p.images.length) ? (p.images.length + ' photos') : '';
                    card.appendChild(meta);
                    card.onclick = () => openChat(p.id, null, 'flower');
                    // ensure manage button passes subject type when present (flowers list)
                    const manageBtn = document.createElement('button');
                    manageBtn.className = 'plant-manage'; manageBtn.type = 'button'; manageBtn.title = 'Manage photos'; manageBtn.setAttribute('aria-label', 'Manage photos');
                    manageBtn.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden>
                        <circle cx="5" cy="12" r="1.6" fill="currentColor" />
                        <circle cx="12" cy="12" r="1.6" fill="currentColor" />
                        <circle cx="19" cy="12" r="1.6" fill="currentColor" />
                    </svg>
                `;
                    manageBtn.addEventListener('click', (e) => { e.stopPropagation(); showManageModal(Object.assign({ _type: 'flower' }, p)); });
                    card.appendChild(manageBtn);
                    container.appendChild(card);
                });
            } catch (e) {
                console.error('Failed to load flowers:', e);
                const container = document.getElementById('plants');
                if (container) {
                    container.innerHTML = '<div class="small" style="color: #d32f2f;">Failed to load flowers. Please check your connection.</div>';
                }
            }
            // Ensure label is correct after loading
            if (activeTab === 'flowers') {
                const filterAll = document.getElementById('filter-all');
                if (filterAll) filterAll.textContent = 'All Flowers';
            }
        }

        // Insert or update a single subject card in the current list without reloading everything
        function insertOrUpdateCard(subjectType, subj) {
            try {
                const container = document.getElementById('plants');
                if (!container || !subj) return;
                // find existing card by data-id
                const existing = container.querySelector(`[data-id='${subj.id}']`);
                const last = subj.images && subj.images.length ? subj.images[subj.images.length - 1] : null;
                if (existing) {
                    const img = existing.querySelector('img');
                    if (img && last) img.src = `/uploads/${last.filename}?t=${Date.now()}`;
                    const name = existing.querySelector('.plant-name'); if (name) name.textContent = subj.nickname || subj.species || 'Unknown';
                    const meta = existing.querySelector('.small'); if (meta) meta.textContent = (subj.images && subj.images.length) ? (subj.images.length + ' photos') : '';
                    return;
                }
                // create new card element (similar to loader)
                const card = document.createElement('div'); card.className = 'plant-card'; card.style.position = 'relative'; card.dataset.id = subj.id;
                const img = document.createElement('img'); img.src = last ? `/uploads/${last.filename}?t=${Date.now()}` : '';
                // clicking the image should open chat focused on that image (but don't auto-open)
                img.style.cursor = 'pointer';
                img.addEventListener('click', (ev) => { ev.stopPropagation(); openChat(subj.id, last ? last.id : null, subjectType === 'flower' ? 'flower' : undefined); });
                card.appendChild(img);
                const name = document.createElement('div'); name.className = 'plant-name'; name.textContent = subj.nickname || subj.species || 'Unknown';
                card.appendChild(name);
                const meta = document.createElement('div'); meta.className = 'small'; meta.textContent = (subj.images && subj.images.length) ? (subj.images.length + ' photos') : '';
                card.appendChild(meta);
                // click to open chat
                card.onclick = () => openChat(subj.id, null, subjectType === 'flower' ? 'flower' : undefined);
                // manage button
                const manageBtn = document.createElement('button'); manageBtn.className = 'plant-manage'; manageBtn.type = 'button'; manageBtn.title = 'Manage photos'; manageBtn.setAttribute('aria-label', 'Manage photos');
                manageBtn.innerHTML = `...`;
                manageBtn.addEventListener('click', (e) => { e.stopPropagation(); showManageModal(Object.assign({ _type: subjectType === 'flower' ? 'flower' : 'plant' }, subj)); });
                card.appendChild(manageBtn);
                container.insertBefore(card, container.firstChild);
            } catch (e) { console.warn('insertOrUpdateCard failed', e); }
        }

        // Helper function to build image URLs with API_BASE_URL
        function getImageUrl(filename) {
            if (!filename) return '';
            const baseUrl = (typeof API_BASE_URL !== 'undefined' && API_BASE_URL) 
              ? API_BASE_URL + '/uploads/' 
              : '/uploads/';
            return baseUrl + filename;
        }

        // Basic tab wiring
        const tabPlants = document.getElementById('tab-plants');
        const tabFlowers = document.getElementById('tab-flowers');
        const searchBox = document.getElementById('searchBox');
        let activeTab = 'plants';

        // Ensure Plants tab is marked as active on page load
        if (tabPlants) tabPlants.classList.add('active');
        if (tabFlowers) tabFlowers.classList.remove('active');

        // Initialize filter label on page load
        const filterAllInit = document.getElementById('filter-all');
        if (filterAllInit) {
            filterAllInit.textContent = 'All Plants';
        }

        // Load plants on page load
        loadPlants();

        // Clear search box when switching tabs and update filter label
        function updateSearchBoxVisibility() {
            if (searchBox) {
                searchBox.value = ''; // clear search when switching tabs
                filterPlants(''); // show all
            }
        }

        // Update filter button label and reload
        function updateTabAndFilters(newTab) {
            activeTab = newTab;
            updateSearchBoxVisibility();

            // Update filter label immediately
            const filterAll = document.getElementById('filter-all');
            if (filterAll) {
                filterAll.textContent = activeTab === 'plants' ? 'All Plants' : 'All Flowers';
            }

            // Load appropriate list
            if (activeTab === 'plants') {
                loadPlants();
            } else {
                loadFlowers();
            }
        }

        if (tabPlants) tabPlants.addEventListener('click', () => {
            tabPlants.classList.add('active');
            tabFlowers.classList.remove('active');
            updateTabAndFilters('plants');
        });

        if (tabFlowers) tabFlowers.addEventListener('click', () => {
            tabFlowers.classList.add('active');
            tabPlants.classList.remove('active');
            updateTabAndFilters('flowers');
        });

        // Owner filter buttons
        const filterAll = document.getElementById('filter-all');
        const filterMother = document.getElementById('filter-mother');
        const filterFriend = document.getElementById('filter-friend');

        function updateFilterButtons() {
            if (filterAll) filterAll.classList.toggle('active', currentOwnerFilter === 'all');
            if (filterMother) filterMother.classList.toggle('active', currentOwnerFilter === 'mother');
            if (filterFriend) filterFriend.classList.toggle('active', currentOwnerFilter === 'friend');
        }

        if (filterAll) filterAll.addEventListener('click', () => {
            currentOwnerFilter = 'all';
            updateFilterButtons();
            activeTab === 'plants' ? loadPlants() : loadFlowers();
        });

        if (filterMother) filterMother.addEventListener('click', () => {
            currentOwnerFilter = 'mother';
            updateFilterButtons();
            activeTab === 'plants' ? loadPlants() : loadFlowers();
        });

        if (filterFriend) filterFriend.addEventListener('click', () => {
            currentOwnerFilter = 'friend';
            updateFilterButtons();
            activeTab === 'plants' ? loadPlants() : loadFlowers();
        });

        // Search/filter functionality
        function filterPlants(query) {
            const plants = document.querySelectorAll('.plant-card');
            const lowerQuery = query.toLowerCase().trim();

            plants.forEach(card => {
                const nameEl = card.querySelector('.plant-name');
                const name = nameEl ? nameEl.textContent.toLowerCase() : '';

                if (!lowerQuery || name.includes(lowerQuery)) {
                    card.style.display = 'flex'; // reset to flex (for column layout)
                } else {
                    card.style.display = 'none';
                }
            });
        }

        if (searchBox) {
            searchBox.addEventListener('input', (e) => {
                filterPlants(e.target.value);
            });
        }

        // Subscribe to server-sent events for enrichment notifications
        try {
            if (typeof EventSource !== 'undefined') {
                const eventsUrl = (typeof API_BASE_URL !== 'undefined' && API_BASE_URL) 
                  ? API_BASE_URL + '/events' 
                  : '/events';
                const es = new EventSource(eventsUrl);
                es.addEventListener('open', () => console.log('SSE connected'));
                es.addEventListener('error', (e) => { /* ignore, connection may auto-retry */ });
                es.addEventListener('enriched', (ev) => {
                    try {
                        const payload = JSON.parse(ev.data || '{}');
                        const sid = payload.subjectId;
                        const stype = payload.subjectType || 'plant';
                        console.log('SSE enriched', payload);
                        // if the chat for this subject is currently open, refresh it
                        if (currentPlant && currentPlant.id === sid) {
                            // refresh messages for current subject
                            openChat(sid, null, stype === 'flower' ? 'flower' : undefined);
                        } else {
                            // otherwise add a subtle badge to the gallery card so user knows an enriched reply is available
                            const c = document.querySelector(`#plants [data-id='${sid}']`);
                            if (c && !c.querySelector('.enriched-badge')) {
                                const b = document.createElement('div'); b.className = 'enriched-badge'; b.textContent = 'AI';
                                b.title = 'New AI reply available';
                                b.style.position = 'absolute'; b.style.right = '8px'; b.style.top = '8px'; b.style.background = 'var(--accent)'; b.style.color = '#fff'; b.style.padding = '4px 6px'; b.style.borderRadius = '6px'; b.style.fontSize = '12px';
                                c.appendChild(b);
                            }
                        }
                    } catch (e) { console.warn('Failed to handle enriched event', e); }
                });
                es.addEventListener('categorized', (ev) => {
                    try {
                        const payload = JSON.parse(ev.data || '{}');
                        const sid = payload.subjectId;
                        const newType = payload.subjectType || 'plant';
                        console.log('ðŸŒ¸ SSE categorized event received:', payload);

                        // Remove from current list (if visible)
                        const card = document.querySelector(`#plants [data-id='${sid}']`);
                        if (card) {
                            console.log('Removing card from current view...');
                            card.remove();
                        }

                        // Update activeTab and toggle UI buttons using correct IDs
                        const tabFlowers = document.getElementById('tab-flowers');
                        const tabPlants = document.getElementById('tab-plants');

                        if (newType === 'flower') {
                            activeTab = 'flowers';
                            console.log('ðŸŒ¸ Switching to Flowers tab and reloading...');
                            if (tabFlowers) {
                                tabFlowers.classList.add('active');
                                console.log('Added active class to flowers tab');
                            }
                            if (tabPlants) {
                                tabPlants.classList.remove('active');
                                console.log('Removed active class from plants tab');
                            }
                            loadFlowers();
                        } else {
                            activeTab = 'plants';
                            console.log('ðŸŒ± Switching to Plants tab and reloading...');
                            if (tabPlants) {
                                tabPlants.classList.add('active');
                                console.log('Added active class to plants tab');
                            }
                            if (tabFlowers) {
                                tabFlowers.classList.remove('active');
                                console.log('Removed active class from flowers tab');
                            }
                            loadPlants();
                        }

                        // If this item was selected, clear the chat
                        if (currentPlant && currentPlant.id === sid) {
                            currentPlant = null;
                            const msgs = document.getElementById('messages');
                            if (msgs) msgs.innerHTML = '<div class="empty">ðŸŒ±</div>';
                        }
                    } catch (e) { console.warn('Failed to handle categorized event', e); }
                });
            }
        } catch (e) { console.warn('SSE not supported', e); }

        function openUploadForPlant(plantId) {
            const panel = document.getElementById('uploadPanel');
            resetUploadForm();
            if (panel) { panel.classList.remove('collapsed'); panel.classList.add('expanded'); }
            // Do not auto-open the file picker here. Let the user click 'Choose photo' to avoid
            // triggering the picker twice (this was causing double prompts).
        }

        function formatTime(iso) { const d = new Date(iso); return d.toLocaleString() }

        // Helper: Fetch with retry and XMLHttpRequest fallback
        async function fetchWithFallback(url, options = {}) {
            const maxRetries = 3;
            let lastError = null;

            // Prepend API_BASE_URL if url is relative
            const fullUrl = typeof API_BASE_URL !== 'undefined' && url.startsWith('/')
                ? API_BASE_URL + url
                : url;

            // Try fetch first (with retries)
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const res = await fetch(fullUrl, options);
                    if (res.ok) return res;
                    // If 404, don't retry
                    if (res.status === 404) return res;
                    lastError = new Error(`HTTP ${res.status}`);
                } catch (e) {
                    lastError = e;
                    if (i < maxRetries - 1) {
                        // Wait before retry (exponential backoff)
                        await new Promise(resolve => setTimeout(resolve, 100 * Math.pow(2, i)));
                    }
                }
            }

            // If fetch failed, try XMLHttpRequest as fallback
            console.warn('Fetch failed, trying XMLHttpRequest fallback...');
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.open(options.method || 'GET', fullUrl, true);
                xhr.responseType = 'json';

                // Set headers if provided
                if (options.headers) {
                    Object.keys(options.headers).forEach(key => {
                        xhr.setRequestHeader(key, options.headers[key]);
                    });
                }

                xhr.onload = () => {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        // Create a fetch-like response object
                        const response = {
                            ok: true,
                            status: xhr.status,
                            statusText: xhr.statusText,
                            json: async () => xhr.response || JSON.parse(xhr.responseText),
                            text: async () => xhr.responseText
                        };
                        resolve(response);
                    } else {
                        const response = {
                            ok: false,
                            status: xhr.status,
                            statusText: xhr.statusText,
                            json: async () => ({}),
                            text: async () => xhr.responseText
                        };
                        resolve(response);
                    }
                };

                xhr.onerror = () => {
                    reject(new Error('XMLHttpRequest failed: Network error'));
                };

                xhr.ontimeout = () => {
                    reject(new Error('XMLHttpRequest timeout'));
                };

                xhr.timeout = 10000; // 10 second timeout
                xhr.send(options.body || null);
            });
        }

        async function openChat(id, imageId, subjectType) {
            try {
                if (imageId) selectedImageId = imageId;
                let res;
                // If caller hints the subjectType, prefer that endpoint first
                try {
                    if (subjectType === 'flower') {
                        res = await fetchWithFallback(`/flowers/${id}`);
                        if (!res.ok && res.status === 404) res = await fetchWithFallback(`/plants/${id}`);
                    } else {
                        // default: try plants first, then flowers
                        res = await fetchWithFallback(`/plants/${id}`);
                        if (!res.ok && res.status === 404) {
                            res = await fetchWithFallback(`/flowers/${id}`);
                        }
                    }
                } catch (fetchError) {
                    console.error('Network error fetching subject:', fetchError);
                    // Check if Chrome thinks we're offline
                    if (!navigator.onLine) {
                        alert('Chrome thinks you are offline. Please:\n1. Check DevTools Network tab - set throttling to "No throttling"\n2. Make sure "Offline" is not checked\n3. Try refreshing the page (Ctrl+Shift+R)');
                    } else {
                        alert('Network error: Unable to connect to server. The server might be down or Chrome is blocking requests. Please check:\n1. Server is running on port 3000\n2. DevTools Network tab settings\n3. Try closing and reopening DevTools');
                    }
                    return;
                }
                if (!res || !res.ok) {
                    console.error('Failed to load subject:', id, res ? res.status : 'network error');
                    alert('Failed to load plant. Please check your connection and make sure the server is running.');
                    return;
                }
                const p = await res.json();
                currentPlant = p;
                const manageBtnEl = document.getElementById('managePhotosBtn');
                if (manageBtnEl) manageBtnEl.disabled = false;
                document.getElementById('chatTitle').textContent = (p.nickname || p.species || 'Plant');
                // show identification meta if available
                const header = document.getElementById('chatHeader');
                let meta = '';
                if (p.identification && p.identification.species) {
                    meta = `Identified as ${p.identification.species}` + (p.identification.probability ? ` (${Math.round(p.identification.probability * 100)}% confidence)` : '');
                } else if (p.species) {
                    meta = `Species: ${p.species}`;
                }
                if (p.careHint) meta += (meta ? ' Â· ' : '') + p.careHint;
                // inject small meta line
                let metaEl = document.getElementById('chatMeta');
                if (!metaEl) { metaEl = document.createElement('div'); metaEl.id = 'chatMeta'; metaEl.className = 'small'; document.getElementById('chatHeader').appendChild(metaEl); }
                metaEl.textContent = meta;

                const msgs = document.getElementById('messages'); msgs.innerHTML = '';

                // If a gallery card had an enriched badge for this subject, remove it when opening chat
                try { const card = document.querySelector(`#plants [data-id='${id}']`); if (card) { const b = card.querySelector('.enriched-badge'); if (b) b.remove(); } } catch (e) { }

                // show images (click an image to focus replies on it)
                if (p.images && p.images.length) {
                    p.images.forEach(img => {
                        const el = document.createElement('div'); el.className = 'msg';
                        // Render image without exposed uploadedAt metadata (keeps data in DB but not shown)
                        el.innerHTML = `<div><img data-fn='${img.filename}' src='/uploads/${img.filename}?t=${Date.now()}' data-imgid='${img.id}' style='max-width:160px; max-height:140px; border-radius:8px; cursor:pointer; opacity:0.01' title='Click to focus replies on this photo'></div>`;
                        msgs.appendChild(el);
                        try {
                            const imgEl = el.querySelector('img[data-imgid]');
                            if (imgEl) {
                                // fade in when loaded
                                imgEl.addEventListener('load', () => { try { imgEl.style.transition = 'opacity 160ms ease'; imgEl.style.opacity = '1'; } catch (e) { } });
                                imgEl.addEventListener('error', () => { try { imgEl.style.opacity = '1'; imgEl.style.background = '#f6faf6'; } catch (e) { } });
                                imgEl.addEventListener('click', (ev) => {
                                    ev.stopPropagation();
                                    // set selected image id for subsequent replies and visually highlight
                                    selectedImageId = img.id;
                                    // remove existing highlights
                                    document.querySelectorAll('#messages img').forEach(i => i.style.boxShadow = '');
                                    imgEl.style.boxShadow = '0 0 0 3px rgba(34,139,34,0.45)';
                                    // scroll the image into view
                                    try { imgEl.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch (e) { }
                                    console.log('selectedImageId set to', selectedImageId);
                                });
                            }
                        } catch (e) { console.warn('attach image click failed', e); }
                    });
                }

                // sync server conversations to local storage (preserve server truth)
                try { saveConv(p.id, p.conversations || []); } catch (e) { }
                // show full conversation history (latest at bottom)
                (p.conversations || []).forEach(m => {
                    const isUser = m.role === 'user';
                    // try to map imageId to filename
                    let imgFn = null;
                    if (m.imageId && p.images && p.images.length) {
                        const found = p.images.find(i => i.id === m.imageId);
                        if (found) imgFn = found.filename;
                    }
                    appendMessageEl(m.role === 'user' ? 'user' : 'plant', m.text, m.time, imgFn, m.imageId || null, m.growthDelta || null, m.text_en, m.text_kn);
                });

                // hide history panel initially
                const historyContainer = document.getElementById('historyContainer'); if (historyContainer) historyContainer.style.display = 'none';
                const managePhotosContainer = document.getElementById('managePhotosContainer'); if (managePhotosContainer) managePhotosContainer.style.display = 'none';

                // scroll
                msgs.scrollTop = msgs.scrollHeight;

                // if an imageId was provided, try to scroll to and highlight that image
                if (imageId) {
                    try {
                        const target = document.querySelector(`#messages img[data-imgid='${imageId}']`);
                        if (target) {
                            target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            target.style.boxShadow = '0 0 0 3px rgba(100,180,100,0.6)';
                            setTimeout(() => { try { target.style.boxShadow = ''; } catch (e) { } }, 2500);
                        }
                    } catch (e) { console.error('scroll to image failed', e); }
                }

                // wire management buttons
                if (manageBtnEl) manageBtnEl.onclick = () => {
                    const c = document.getElementById('managePhotosContainer');
                    if (!c) return;
                    if (c.style.display === 'block') { c.style.display = 'none'; return; }
                    c.innerHTML = '';
                    if (!p.images || !p.images.length) { c.innerHTML = '<div class="small">No photos to manage.</div>'; c.style.display = 'block'; return; }
                    p.images.forEach(img => {
                        const row = document.createElement('div'); row.className = 'manage-row';
                        row.innerHTML = `
                                            <div style='display:flex; gap:8px; align-items:center; flex:0 0 auto'>
                                                <img src='/uploads/${img.filename}' style='width:64px; height:48px; object-fit:cover; border-radius:6px' data-fn='${img.filename}'>
                                            </div>
                                            <!-- uploadedAt hidden from UI by default; data still available on server -->
                                            <div style='flex:0 0 auto'><button class='ghost small delete-small' data-img='${img.id}' data-fn='${img.filename}'>Delete</button></div>
                                        `;
                        c.appendChild(row);
                        const del = row.querySelector('button[data-img]');
                        del.addEventListener('click', async () => {
                            if (!confirm('Delete this photo?')) return;
                            try {
                                const filename = del.getAttribute('data-fn');
                                const imgId = del.getAttribute('data-img');
                                // Try plants delete first, if 404 then try flowers delete
                                let url = `/plants/${p.id}/images/${imgId}`;
                                console.log('DELETE request URL:', url);
                                let r = await fetch(url, { method: 'DELETE' });
                                if (!r.ok && r.status === 404) {
                                    // try flowers
                                    url = `/flowers/${p.id}/images/${imgId}`;
                                    console.log('Fallback DELETE request URL:', url);
                                    r = await fetch(url, { method: 'DELETE' });
                                }
                                const txt = await r.text();
                                if (!r.ok) return alert('Failed to delete: ' + (txt || r.status));
                                // remove this manage-row and any message UI immediately
                                try { row.remove(); } catch (e) { }
                                removeImageUI(filename);
                                await loadPlants();
                                openChat(p.id);
                            } catch (e) { console.error(e); alert('Delete failed: ' + (e && e.message)); }
                        });
                    });
                    c.style.display = 'block';
                };

                // wire history toggle
                const histBtn = document.getElementById('toggleHistoryBtn');
                if (histBtn) histBtn.onclick = () => {
                    const c = document.getElementById('historyContainer');
                    if (!c) return;
                    if (c.style.display === 'block') { c.style.display = 'none'; histBtn.textContent = 'Show history'; return; }
                    c.innerHTML = '';
                    const history = (p.conversations || []).slice().reverse();
                    if (!history.length) { c.innerHTML = '<div class="small">No history.</div>'; c.style.display = 'block'; histBtn.textContent = 'Hide history'; return; }
                    history.forEach(m => {
                        const r = document.createElement('div'); r.className = 'msg ' + (m.role === 'user' ? 'user' : '');
                        // hidden details (time, imageId, growth)
                        const detailsHtml = `<div class='msg-details' style='display:none; font-size:12px; color:var(--muted); margin-top:6px;'>${m.time ? formatTime(m.time) : ''}${m.imageId ? ' Â· image: ' + m.imageId : ''}${typeof m.growthDelta === 'number' ? (' Â· growth: ' + Math.round(m.growthDelta * 100) + '%') : ''}</div>`;
                        r.innerHTML = `<div>${m.text}</div>${detailsHtml}<button class='ghost small details-btn' style='margin-top:6px'>Details</button>`;
                        c.appendChild(r);
                        const btn = r.querySelector('.details-btn'); const d = r.querySelector('.msg-details'); if (btn && d) btn.addEventListener('click', () => { d.style.display = d.style.display === 'none' ? 'block' : 'none'; });
                    });
                    c.style.display = 'block'; histBtn.textContent = 'Hide history';
                };

                // Display new UI enhancements
                updateHealthDashboard(p);
                displayGrowthChart(p);
                displayMilestones(p);
                displayGrowthPrompt(p);

                // Wire compare button to use first image comparison
                const compareBtn = document.getElementById('compareBtn');
                if (compareBtn && p.images && p.images.length >= 2) {
                    compareBtn.onclick = () => openCompareModal(p, p.images.length - 2, p.images.length - 1);
                }
            } catch (error) {
                console.error('Error opening chat:', error);
                // Handle network errors gracefully
                if (error instanceof TypeError && error.message.includes('fetch')) {
                    alert('Network error: Unable to connect to the server. Please check your connection and make sure the server is running.');
                } else {
                    alert('Failed to load plant. Please try again.');
                }
            }
        }

        function appendMessageEl(role, text, time, imageFilename, imageId, growthDelta, text_en, text_kn) {
            const msgs = document.getElementById('messages');
            if (!msgs) return;
            // remove empty placeholder
            const empty = msgs.querySelector('.empty'); if (empty) empty.remove();
            const el = document.createElement('div'); el.className = 'msg' + (role === 'user' ? ' user' : '');
            let html = '';
            if (imageFilename) html += `<div style='margin-bottom:8px'><img data-fn='${imageFilename}' src='/uploads/${imageFilename}' style='max-width:220px; border-radius:8px'></div>`;
            // Store growth data for internal use but don't display any technical info
            html += `<div>${text}${imageId ? ' ðŸ“·' : ''}</div>`;
            el.innerHTML = html;
            if (imageId) el.dataset.imgid = imageId;
            if (typeof growthDelta === 'number') el.dataset.growthdelta = growthDelta;
            // Store translations for replay button
            if (text_en) el.dataset.text_en = text_en;
            if (text_kn) el.dataset.text_kn = text_kn;

            // Add audio button for plant messages (on all devices)
            if (role === 'plant') {
                const audioBtn = document.createElement('button');
                audioBtn.className = 'ghost small';
                audioBtn.style.marginTop = '6px';

                // Show replay button on all devices
                audioBtn.textContent = 'ðŸ”Š Replay';
                audioBtn.onclick = async () => {
                    try {
                        console.log('ðŸ”Š Replay button clicked for text:', text.substring(0, 30));
                        console.log('ðŸ“ Current language setting:', currentLanguage);

                        // Check if we have stored translations
                        const storedEn = el.dataset.text_en;
                        const storedKn = el.dataset.text_kn;

                        console.log('ðŸ“ Available translations - EN:', !!storedEn, 'KN:', !!storedKn);

                        // Use stored translation if available
                        if (currentLanguage === 'en' && storedEn) {
                            console.log('âœ… Using stored English translation');
                            speak(storedEn);
                            return;
                        } else if (currentLanguage === 'kn' && storedKn) {
                            console.log('âœ… Using stored Kannada translation');
                            speak(storedKn);
                            return;
                        }

                        // Fallback: detect language and use original
                        const kannadaRegex = /[\u0C80-\u0CFF]/;
                        const textIsKannada = kannadaRegex.test(text);

                        if ((currentLanguage === 'kn' && !textIsKannada) || (currentLanguage === 'en' && textIsKannada)) {
                            console.log('âš ï¸ No stored translation, fetching on-demand...');

                            // Fallback to on-demand translation if no stored version
                            try {
                                const headers = { 'Content-Type': 'application/json' };
                                if (INVITE_TOKEN) headers['x-invite-token'] = INVITE_TOKEN;

                                const payload = {
                                    text: text,
                                    targetLanguage: currentLanguage
                                };

                                const r = await fetch('/translate', {
                                    method: 'POST',
                                    headers,
                                    body: JSON.stringify(payload)
                                });

                                if (r.ok) {
                                    const jd = await r.json();
                                    if (jd && jd.translatedText) {
                                        console.log('âœ… Translation received, speaking:', jd.translatedText.substring(0, 30));
                                        speak(jd.translatedText);
                                        return;
                                    }
                                }
                            } catch (translateErr) {
                                console.log('âš ï¸ Translation not available, speaking original text');
                            }
                        }

                        // Otherwise speak the original text
                        speak(text);
                    } catch (err) {
                        console.error('âŒ Error in replay button onclick:', err);
                        speak(text);
                    }
                };
                el.appendChild(audioBtn);
            }

            msgs.appendChild(el);
            // if this message had an image, attach click handler so user can focus replies on it
            try {
                if (imageId) {
                    const justImg = el.querySelector('img');
                    if (justImg) {
                        // cache-bust freshly uploaded images so the browser fetches the new file
                        try {
                            const fn = justImg.getAttribute('data-fn');
                            if (fn) justImg.src = `/uploads/${fn}?t=${Date.now()}`;
                        } catch (e) { }
                        justImg.style.cursor = 'pointer';
                        justImg.title = 'Click to focus replies on this photo';
                        // show a subtle loading indicator until image finishes loading
                        justImg.style.opacity = '0.01';
                        justImg.addEventListener('load', () => { justImg.style.transition = 'opacity 180ms ease'; justImg.style.opacity = '1'; });
                        justImg.addEventListener('error', () => {
                            // if image fails to load, show a simple placeholder background and border
                            justImg.style.opacity = '1';
                            justImg.style.background = '#f6faf6';
                            justImg.style.border = '1px dashed rgba(34,140,60,0.12)';
                            justImg.alt = 'Image not available yet';
                        });
                        justImg.addEventListener('click', (ev) => {
                            ev.stopPropagation();
                            selectedImageId = imageId;
                            document.querySelectorAll('#messages img').forEach(i => i.style.boxShadow = '');
                            justImg.style.boxShadow = '0 0 0 3px rgba(34,139,34,0.45)';
                            try { justImg.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch (e) { }
                            console.log('selectedImageId set to', selectedImageId);
                        });
                    }
                }
            } catch (e) { console.warn('attach click to appended image failed', e); }
            msgs.scrollTop = msgs.scrollHeight;
        }

        // Remove image message elements matching filename from the messages area
        function removeImageUI(filename) {
            if (!filename) return;
            try {
                const msgs = document.getElementById('messages');
                if (!msgs) return;
                msgs.querySelectorAll('img').forEach(imgEl => {
                    try {
                        if (imgEl.src && imgEl.src.indexOf('/uploads/' + filename) !== -1) {
                            const msgEl = imgEl.closest('.msg'); if (msgEl) msgEl.remove();
                        }
                    } catch (e) { }
                });
                if (!msgs.querySelector('.msg')) msgs.innerHTML = '<div class="empty">ðŸŒ±</div>';
            } catch (e) { console.error('removeImageUI failed', e); }
        }

        // speak text with browser TTS (improved: prefer sweeter / non-male voices)
        let TTS_VOICES = [];
        function loadTTSVoices() {
            if (!('speechSynthesis' in window)) return;
            TTS_VOICES = window.speechSynthesis.getVoices() || [];
            if (!TTS_VOICES.length) {
                // voices may load asynchronously
                window.speechSynthesis.onvoiceschanged = () => { TTS_VOICES = window.speechSynthesis.getVoices() || []; };
            }
        }

        function chooseSweetVoice(forceLang = null) {
            if (!TTS_VOICES || !TTS_VOICES.length) return null;

            // Use forced language or fall back to app language
            const langCode = forceLang || currentLanguage || 'en';
            console.log('ðŸ”Š Looking for voice with language:', langCode);
            console.log('ðŸ”Š Available voices:', TTS_VOICES.map(v => `${v.name} (${v.lang})`).join(', '));

            // If Kannada, look for Kannada voices
            if (langCode === 'kn') {
                const kannadaVoices = TTS_VOICES.filter(v =>
                    (v.lang && (v.lang.toLowerCase().includes('kn') || v.lang.toLowerCase().startsWith('kn-'))) ||
                    (v.name && v.name.toLowerCase().includes('kannada'))
                );
                console.log('ðŸ”Š Kannada voices found:', kannadaVoices.map(v => v.name));
                if (kannadaVoices.length > 0) {
                    console.log('ðŸ”Š Using Kannada voice:', kannadaVoices[0].name);
                    return kannadaVoices[0];
                }
            }

            // For English, prioritize actual English/US/UK voices
            const englishVoices = TTS_VOICES.filter(v => {
                const lang = (v.lang || '').toLowerCase();
                const name = (v.name || '').toLowerCase();
                return lang.includes('en-us') || lang.includes('en-gb') ||
                    lang.startsWith('en') || name.includes('english') ||
                    name.includes('google us') || name.includes('google uk');
            });

            console.log('ðŸ”Š English voices found:', englishVoices.map(v => `${v.name} (${v.lang})`));

            if (englishVoices.length > 0) {
                // Prefer female English voices
                const femaleEnglish = englishVoices.find(v =>
                    /female|woman|fem|victoria|samantha|nora|amelia/i.test(v.name || '')
                );
                if (femaleEnglish) {
                    console.log('ðŸ”Š Using English female voice:', femaleEnglish.name);
                    return femaleEnglish;
                }
                console.log('ðŸ”Š Using first available English voice:', englishVoices[0].name);
                return englishVoices[0];
            }

            // Fallback: use preferred voices
            const preferred = [
                'Samantha', 'Victoria', 'Amelia', 'Nora', 'Kendra', 'Alloy',
                'Google UK English Female', 'Google US English Female',
                'Microsoft Zira', 'Fiona', 'Kate', 'Karen'
            ];
            for (const name of preferred) {
                const v = TTS_VOICES.find(s => s.name && s.name.toLowerCase().includes(name.toLowerCase()));
                if (v) {
                    console.log('ðŸ”Š Using preferred voice:', v.name);
                    return v;
                }
            }

            const female = TTS_VOICES.find(v => /female|woman|fem/i.test(v.name || ''));
            if (female) {
                console.log('ðŸ”Š Using female voice:', female.name);
                return female;
            }

            console.log('ðŸ”Š Using first available voice:', TTS_VOICES[0].name);
            return TTS_VOICES[0] || null;
        }

        // No browser-preference control in UI; speak() will fall back sensibly.

        async function speak(text, opts = {}) {
            if (!text) {
                console.warn('speak() called with empty text');
                return;
            }
            console.log('âœ… speak() called with:', text.substring(0, 30));
            console.log('ðŸ“ Current app language:', currentLanguage);

            try {
                speakWithBrowserTTS(text, opts);
            } catch (err) {
                console.error('âŒ Error calling speakWithBrowserTTS:', err);
            }
        }

        function speakWithBrowserTTS(text, opts = {}) {
            if (!('speechSynthesis' in window)) {
                console.warn('âŒ Speech Synthesis API not available on this device');
                return;
            }

            try {
                // Cancel any previous speech
                window.speechSynthesis.cancel();

                // Small delay to ensure cancel completed
                setTimeout(() => {
                    if (!TTS_VOICES.length) {
                        console.log('Loading TTS voices...');
                        loadTTSVoices();
                    }

                    const utter = new SpeechSynthesisUtterance(text);

                    // Detect text language (check if it contains Kannada characters)
                    const kannadaRegex = /[\u0C80-\u0CFF]/;
                    const isKannada = kannadaRegex.test(text);
                    console.log('ðŸ“ Text is Kannada:', isKannada);

                    // Use chooseSweetVoice to prefer female voices, with language detection
                    const voice = chooseSweetVoice(isKannada ? 'kn' : currentLanguage);

                    if (voice) {
                        utter.voice = voice;
                        utter.lang = voice.lang || 'en-US';
                        console.log(`âœ… Speaking with voice: ${voice.name}, lang: ${voice.lang}`);
                    } else {
                        utter.lang = isKannada ? 'kn-IN' : 'en-US';
                        console.log('âš ï¸ No voice selected, using default lang:', utter.lang);
                    }

                    utter.pitch = typeof opts.pitch === 'number' ? opts.pitch : 1.15;
                    utter.rate = typeof opts.rate === 'number' ? opts.rate : 0.95;
                    utter.volume = 1.0;  // MAX VOLUME

                    let retryCount = 0;
                    const maxRetries = 2;

                    // Add event listeners for debugging
                    utter.onstart = () => {
                        console.log('ðŸ”Š Speech started');
                    };

                    utter.onend = () => {
                        console.log('ðŸ”Š Speech ended successfully');
                    };

                    utter.onerror = (event) => {
                        console.error('âŒ Speech error:', event.error);

                        // Handle specific errors
                        if (event.error === 'interrupted') {
                            console.log('âš ï¸ Speech was interrupted - retrying...');
                            if (retryCount < maxRetries) {
                                retryCount++;
                                console.log(`ðŸ”„ Retry attempt ${retryCount}/${maxRetries}`);
                                // Retry after a small delay
                                setTimeout(() => {
                                    try {
                                        window.speechSynthesis.cancel();
                                        window.speechSynthesis.speak(utter);
                                    } catch (e) {
                                        console.error('Retry failed:', e);
                                    }
                                }, 300);
                            }
                        } else if (event.error === 'audio-busy') {
                            console.log('âš ï¸ Audio is busy - another app may be using the speaker');
                        } else if (event.error === 'network') {
                            console.log('âš ï¸ Network error - check internet connection');
                        }
                    };

                    console.log('ðŸ”Š Starting speech synthesis:', text.substring(0, 50) + '...');
                    window.speechSynthesis.speak(utter);
                }, 100);
            } catch (e) {
                console.error('âŒ Error in speakWithBrowserTTS:', e);
            }
        }

        // ensure voices are loaded early
        window.addEventListener('load', () => { loadTTSVoices(); setTimeout(loadTTSVoices, 500); });

        // Expose speak function globally for testing
        window.speak = speak;
        window.testSpeak = () => {
            console.log('Testing speaker with simple text...');
            speak('Hello, I am a plant! How are you doing today?');
        };
        console.log('âœ… Speaker functions available. Test with: window.testSpeak()');


        // Invite token support: read from localStorage so single-user deployments can set it in the browser
        // If your server sets INVITE_TOKEN in the environment, store it in localStorage under 'inviteToken'
        let INVITE_TOKEN = localStorage.getItem('inviteToken') || null;

        function getAuthHeaders() {
            const h = {};
            if (INVITE_TOKEN) h['x-invite-token'] = INVITE_TOKEN;
            return h;
        }

        // Upload handler (debounced to prevent double submits)
        (function () {
            let uploading = false;
            const form = document.getElementById('uploadForm');
            const progressBarFill = document.createElement('div');
            progressBarFill.className = 'progress-bar-fill';
            const progressBarBg = document.createElement('div');
            progressBarBg.className = 'progress-bar-bg';
            progressBarBg.appendChild(progressBarFill);
            const progressWrapper = document.createElement('div');
            progressWrapper.className = 'upload-progress';
            const progressText = document.createElement('div'); progressText.id = 'uploadProgressText'; progressText.textContent = '';
            progressWrapper.appendChild(progressBarBg); progressWrapper.appendChild(progressText);
            if (form) form.appendChild(progressWrapper);

            async function doUploadWithProgress(formData, headers = {}) {
                return new Promise((resolve, reject) => {
                    const xhr = new XMLHttpRequest();
                    const uploadUrl = (typeof API_BASE_URL !== 'undefined' && API_BASE_URL) 
                      ? API_BASE_URL + '/upload' 
                      : '/upload';
                    xhr.open('POST', uploadUrl);
                    Object.keys(headers || {}).forEach(k => xhr.setRequestHeader(k, headers[k]));
                    xhr.upload.onprogress = function (e) {
                        if (!e.lengthComputable) return;
                        const pct = Math.round((e.loaded / e.total) * 100);
                        progressBarFill.style.width = pct + '%';
                        progressText.textContent = pct + '%';
                    };
                    xhr.onload = function () {
                        if (xhr.status >= 200 && xhr.status < 300) {
                            try { const jd = JSON.parse(xhr.responseText); resolve({ ok: true, json: async () => jd, status: xhr.status }); } catch (e) { resolve({ ok: true, json: async () => ({}), status: xhr.status }); }
                        } else if (xhr.status === 401) {
                            resolve({ ok: false, status: 401, text: async () => xhr.responseText });
                        } else {
                            resolve({ ok: false, status: xhr.status, text: async () => xhr.responseText });
                        }
                    };
                    xhr.onerror = function () { reject(new Error('Upload failed')); };
                    xhr.send(formData);
                });
            }

            // Attach upload submit handler safely. The upload form was moved in the DOM
            // so it may not exist at script run-time. Create a named handler and attach
            // it either directly to the form or via delegated submit listener as a fallback.
            async function handleUploadSubmit(e) {
                e.preventDefault();
                if (uploading) return;
                const fileEl = document.getElementById('photo');
                const file = fileEl && fileEl.files && fileEl.files[0];
                if (!file) return alert('Select a photo');
                if (file.size === 0) return alert('Selected file is empty');
                const owner = (document.getElementById('ownerSelect') || {}).value || '';
                if (!owner) {
                    // Remove any existing error message
                    const existingError = document.getElementById('uploadError');
                    if (existingError) existingError.remove();
                    // Create and show error message on the form
                    const errorDiv = document.createElement('div');
                    errorDiv.id = 'uploadError';
                    errorDiv.style.cssText = 'background:#f44336; color:white; padding:10px 12px; margin-bottom:12px; border-radius:4px; font-size:13px; display:flex; align-items:center; gap:8px;';
                    errorDiv.innerHTML = 'âš ï¸ Please select whose plant this is (Amma or Ammulu)';
                    const uploadForm = document.getElementById('uploadForm');
                    if (uploadForm) uploadForm.insertBefore(errorDiv, uploadForm.firstChild);
                    return;
                }
                uploading = true;
                const form = document.getElementById('uploadForm');
                const uploadBtn = (form && form.querySelector) ? form.querySelector('button.primary') : null;
                if (uploadBtn) { uploadBtn.disabled = true; uploadBtn.textContent = 'Uploading...'; }
                // resize
                let toSend = file;
                try { toSend = await resizeImageFile(file, 1024); } catch (e) { toSend = file; }
                const nickname = (document.getElementById('nickname') || {}).value || '';
                const fd = new FormData();
                fd.append('photo', toSend);
                fd.append('nickname', nickname);
                if (owner) fd.append('owner', owner);

                // Don't send subjectType - server will auto-detect if it's a flower or plant based on species
                // prepare headers
                const authH = getAuthHeaders();
                // show progress UI
                progressBarFill.style.width = '0%'; progressText.textContent = '0%'; progressWrapper.style.display = 'flex';
                try {
                    const res = await doUploadWithProgress(fd, authH);
                    if (!res.ok && res.status === 401) {
                        const token = prompt('Server requires an invite token. Enter it now (you can store it in the browser):');
                        if (token) { INVITE_TOKEN = token; localStorage.setItem('inviteToken', token); authH['x-invite-token'] = token; }
                    }
                    const data = await res.json();
                    if (uploadBtn) { uploadBtn.disabled = false; uploadBtn.textContent = 'Upload'; }
                    uploading = false;
                    if (!data.success) return alert('Upload failed: ' + (data.error || 'unknown'));
                    // UI updates (same as previous flow)
                    const subjType = data.subjectType || 'plant';
                    const subjObj = data[subjType] || data.plant || data.flower || null;
                    const subjId = subjObj ? subjObj.id : null;
                    // Do not auto-insert a placeholder conversation entry or auto-open the chat.
                    // The user wants the upload to appear in the gallery only. They can click the image to open chat.
                    try {
                        // Don't use insertOrUpdateCard - reload immediately to show the new item
                        // This ensures proper filtering and categorization
                    } catch (e) { }
                    // Do not auto-open chat or append a plant message. The user will click the image to open the chat and focus it.
                    // close upload panel and reset
                    closeUpload();
                    if (photoInput) { photoInput.value = ''; }
                    if (photoPreview) { photoPreview.src = ''; photoPreview.style.display = 'none'; }
                    if (filePlaceholder) filePlaceholder.style.display = 'block';

                    // Wait a bit longer before reloading to allow background categorization to complete
                    // (If it's a flower detected as plant, it will be moved by the server)
                    await new Promise(resolve => setTimeout(resolve, 2000));

                    // Immediately reload gallery to show the newly uploaded item
                    // Reset filter to 'all' when reloading after upload
                    currentOwnerFilter = 'all';

                    // Update filter buttons to show 'all' is active
                    const filterAll = document.getElementById('filter-all');
                    const filterMother = document.getElementById('filter-mother');
                    const filterFriend = document.getElementById('filter-friend');
                    if (filterAll) {
                        filterAll.classList.add('active');
                    }
                    if (filterMother) filterMother.classList.remove('active');
                    if (filterFriend) filterFriend.classList.remove('active');

                    // Reload both galleries
                    await loadPlants();
                    await loadFlowers();

                    // Now check which gallery contains the uploaded item and switch to that tab
                    if (subjId) {
                        const plantsUrl = (typeof API_BASE_URL !== 'undefined' && API_BASE_URL) 
                          ? API_BASE_URL + '/plants' 
                          : '/plants';
                        const flowersUrl = (typeof API_BASE_URL !== 'undefined' && API_BASE_URL) 
                          ? API_BASE_URL + '/flowers' 
                          : '/flowers';
                        const db = await (await fetch(plantsUrl)).json();
                        const isPlant = db.some(p => p.id === subjId);
                        const isFi = await (await fetch(flowersUrl)).json();
                        const isFlower = isFi.some(f => f.id === subjId);

                        if (isFlower && activeTab !== 'flowers') {
                            activeTab = 'flowers';
                            const tabFlowers = document.getElementById('tab-flowers');
                            const tabPlants = document.getElementById('tab-plants');
                            if (tabFlowers) tabFlowers.classList.add('active');
                            if (tabPlants) tabPlants.classList.remove('active');
                            loadFlowers();
                            filterAll.textContent = 'All Flowers';
                        } else if (isPlant && activeTab !== 'plants') {
                            activeTab = 'plants';
                            const tabPlants = document.getElementById('tab-plants');
                            const tabFlowers = document.getElementById('tab-flowers');
                            if (tabPlants) tabPlants.classList.add('active');
                            if (tabFlowers) tabFlowers.classList.remove('active');
                            loadPlants();
                            filterAll.textContent = 'All Plants';
                        }
                    }
                    // Do not speak the placeholder message automatically on upload.
                } catch (err) {
                    console.error('Upload failed', err); alert('Upload failed: ' + (err && err.message));
                    if (uploadBtn) { uploadBtn.disabled = false; uploadBtn.textContent = 'Upload'; }
                    uploading = false;
                } finally {
                    progressWrapper.style.display = 'none';
                }
            }

            if (form) {
                form.addEventListener('submit', handleUploadSubmit);
            } else {
                // Delegated fallback: listen for submits on document and handle if target is #uploadForm
                document.addEventListener('submit', function (e) {
                    try {
                        const t = e.target;
                        if (t && t.id === 'uploadForm') handleUploadSubmit(e);
                    } catch (ex) { }
                }, true);
            }
        })();

        // ============================================================================
        // WEB SPEECH API - VOICE INPUT
        // ============================================================================

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        console.log('ðŸŽ¤ SpeechRecognition available:', !!SpeechRecognition);
        console.log('ðŸŽ¤ Browser info:', {
            userAgent: navigator.userAgent,
            hasSpeechRecognition: !!window.SpeechRecognition,
            hasWebkitSpeechRecognition: !!window.webkitSpeechRecognition
        });
        let recognition = null;
        let recognitionStarting = false;  // Flag to prevent double-starts

        if (SpeechRecognition) {
            console.log('ðŸŽ¤ Creating new SpeechRecognition instance');
            try {
                recognition = new SpeechRecognition();
                console.log('ðŸŽ¤ SpeechRecognition instance created:', !!recognition);
            } catch (err) {
                console.error('ðŸŽ¤ Failed to create SpeechRecognition:', err);
                recognition = null;
            }

            if (recognition) {
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = currentLanguage === 'kn' ? 'kn-IN' : 'en-US';

                let silenceTimeout = null;
                let lastSpeechTime = 0;

                recognition.onstart = () => {
                    recognitionStarting = false;  // Reset flag when actually started
                    isListening = true;
                    lastSpeechTime = Date.now();
                    const voiceBtn = document.getElementById('voiceBtn');
                    if (voiceBtn) {
                        voiceBtn.classList.add('listening');
                        voiceBtn.title = 'Listening... Click to stop';
                    }
                };

                recognition.onresult = (event) => {
                    lastSpeechTime = Date.now();
                    // Clear previous silence timeout
                    if (silenceTimeout) clearTimeout(silenceTimeout);

                    let transcript = '';
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        transcript += event.results[i][0].transcript;
                    }
                    document.getElementById('replyText').value = transcript;

                    // Set timeout for 5 seconds of silence
                    silenceTimeout = setTimeout(() => {
                        const timeSinceSpeech = Date.now() - lastSpeechTime;
                        if (timeSinceSpeech > 5000) {
                            console.log('5 seconds of silence - stopping and sending');
                            recognition.stop();
                            isListening = false;
                            setTimeout(sendReplyMessage, 500);
                        }
                    }, 5000);
                };

                recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    recognitionStarting = false;  // Reset flag on error
                    if (silenceTimeout) clearTimeout(silenceTimeout);
                    const voiceBtn = document.getElementById('voiceBtn');
                    if (voiceBtn) {
                        voiceBtn.classList.remove('listening');
                        voiceBtn.title = 'Speak to plant (click to record)';
                    }
                    isListening = false;

                    // Show error message on mobile
                    if (isMobile() && event.error) {
                        let errorMsg = '';
                        if (event.error === 'network') errorMsg = 'Network error - check your internet connection';
                        else if (event.error === 'no-speech') errorMsg = 'No speech detected - please try again';
                        else if (event.error === 'audio-capture') errorMsg = 'Microphone not available - check permissions';
                        else if (event.error === 'not-allowed') errorMsg = 'Microphone permission denied';

                        if (errorMsg) console.warn('ðŸŽ¤ ' + errorMsg);
                    }
                };

                recognition.onend = () => {
                    recognitionStarting = false;  // Reset flag when ended
                    isListening = false;
                    const voiceBtn = document.getElementById('voiceBtn');
                    if (voiceBtn) {
                        voiceBtn.classList.remove('listening');
                        voiceBtn.title = 'Speak to plant (click to record)';
                    }
                };
            }
        }

        // Initialize button
        setTimeout(() => {
            const voiceBtn = document.getElementById('voiceBtn');
            console.log('ðŸŽ¤ Voice button initialization:', { found: !!voiceBtn, element: voiceBtn });
            if (voiceBtn) {
                voiceBtn.textContent = 'ðŸŽ¤';
                voiceBtn.disabled = false;
                voiceBtn.style.pointerEvents = 'auto';
                voiceBtn.style.cursor = 'pointer';
                voiceBtn.style.opacity = '1';
                console.log('ðŸŽ¤ Voice button initialized successfully');

                // Use addEventListener for better compatibility
                voiceBtn.addEventListener('click', function (e) {
                    console.log('ðŸŽ¤ onclick handler triggered', { isListening, recognitionStarting, hasRecognition: !!recognition });

                    if (!recognition) {
                        console.log('ðŸŽ¤ No recognition available, showing alert');
                        alert('Voice input is not supported on this browser. Please type your message instead.');
                        return;
                    }

                    e.preventDefault();
                    e.stopPropagation();

                    if (isListening) {
                        console.log('ðŸŽ¤ Stopping listening from onclick');
                        recognition.stop();
                    } else if (!recognitionStarting) {
                        console.log('ðŸŽ¤ Starting recognition from onclick');
                        recognitionStarting = true;
                        document.getElementById('replyText').value = '';
                        try {
                            recognition.start();
                        } catch (err) {
                            console.error('Error starting recognition:', err);
                            recognitionStarting = false;
                        }
                    } else {
                        console.log('ðŸŽ¤ Already starting recognition from onclick');
                    }
                });
            }
        }, 100);

        // Helper function to send reply
        // Track last message to detect duplicates
        let lastMessageText = '';
        let lastMessageTime = 0;

        async function sendReplyMessage() {
            const text = document.getElementById('replyText').value.trim();
            if (!text) return;
            if (!currentPlant) return alert('Choose a plant first');

            // Check for duplicate message sent within 90 seconds
            const now = Date.now();
            const timeSinceLastMessage = (now - lastMessageTime) / 1000;
            const isSimilar = text.toLowerCase() === lastMessageText.toLowerCase();

            if (isSimilar && timeSinceLastMessage < 90) {
                const proceed = confirm(`You just sent: "${text}"\n\nSend it again anyway?`);
                if (!proceed) {
                    document.getElementById('replyText').focus();
                    return;
                }
            }

            // Update last message tracking
            lastMessageText = text;
            lastMessageTime = now;

            const time = new Date().toISOString();
            // save user message locally immediately
            const hist = loadConv(currentPlant.id);
            hist.push({ role: 'user', text, time, text_en: text, text_kn: text });
            saveConv(currentPlant.id, hist);
            appendMessageEl('user', text, time, null, null, null, text, text);

            // send to server for LLM reply (if server has OPENAI key configured)
            try {
                const payload = { plantId: currentPlant.id, text, language: currentLanguage };
                if (selectedImageId) payload.imageId = selectedImageId;
                const headers = { 'Content-Type': 'application/json' };
                if (INVITE_TOKEN) headers['x-invite-token'] = INVITE_TOKEN;
                showTyping();
                const r = await fetch('/reply', { method: 'POST', headers, body: JSON.stringify(payload) });
                const jd = await r.json();
                let plantReply = null;
                if (r.ok && jd && jd.reply) {
                    plantReply = jd.reply;
                } else {
                    // log server problem for debugging and fall back to client generator
                    console.warn('/reply did not return a valid reply', { status: r.status, body: jd });
                    plantReply = generateClientReply(currentPlant, text);
                }
                hideTyping();
                const rt = new Date().toISOString();
                hist.push({ role: 'plant', text: plantReply, time: rt });
                saveConv(currentPlant.id, hist);
                // if server returned image info, store and render it
                const imageFilename = (jd && jd.imageFilename) ? jd.imageFilename : null;
                const imageId = (jd && jd.imageId) ? jd.imageId : null;
                const growthDelta = (jd && typeof jd.growthDelta !== 'undefined') ? jd.growthDelta : null;
                const text_en = (jd && jd.text_en) ? jd.text_en : plantReply;
                const text_kn = (jd && jd.text_kn) ? jd.text_kn : plantReply;
                if (imageId) hist[hist.length - 1].imageId = imageId;
                if (typeof growthDelta === 'number') hist[hist.length - 1].growthDelta = growthDelta;
                hist[hist.length - 1].text_en = text_en;
                hist[hist.length - 1].text_kn = text_kn;
                appendMessageEl('plant', plantReply, rt, imageFilename, imageId, growthDelta, text_en, text_kn);
                speak(plantReply);
            } catch (err) {
                console.error('Reply failed', err);
                const plantReply = generateClientReply(currentPlant, text);
                const rt = new Date().toISOString();
                hist.push({ role: 'plant', text: plantReply, time: rt });
                hist[hist.length - 1].text_en = plantReply;
                hist[hist.length - 1].text_kn = plantReply;
                saveConv(currentPlant.id, hist);
                appendMessageEl('plant', plantReply, rt, null, null, null, plantReply, plantReply);
                speak(plantReply);
            } finally {
                hideTyping();
                document.getElementById('replyText').value = '';
            }
        }


        // Send a reply on button click
        document.getElementById('sendReply').addEventListener('click', sendReplyMessage);

        // Send a reply on Enter key (Shift+Enter for new line on desktop, regular Enter on mobile/tablet)
        document.getElementById('replyText').addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendReplyMessage();
            }
        });

        // Attach speaker button listener with error protection
        try {
            const speakLastBtn = document.getElementById('speakLast');
            if (speakLastBtn) {
                speakLastBtn.addEventListener('click', () => {
                    console.log('ðŸ”Š speakLast button clicked');
                    try {
                        const msgs = document.querySelectorAll('#messages .msg');
                        console.log('ðŸ”Š Found', msgs.length, 'messages');
                        if (!msgs.length) {
                            console.log('ðŸ”Š No messages found');
                            return;
                        }
                        const last = msgs[msgs.length - 1];
                        // Extract only the message text, skip any metadata or timestamps
                        const textDiv = last.querySelector('div:last-of-type');
                        const messageText = textDiv ? textDiv.textContent.trim() : (last.textContent || last.innerText);
                        console.log('ðŸ”Š Extracted message text:', messageText.substring(0, 50));
                        if (messageText) {
                            console.log('ðŸ”Š Calling speak() with message');
                            speak(messageText);
                        } else {
                            console.log('ðŸ”Š No message text found');
                        }
                    } catch (err) {
                        console.error('âŒ Error in speakLast handler:', err);
                    }
                });
                console.log('âœ… speakLast button listener attached');
            } else {
                console.warn('âš ï¸ speakLast button not found');
            }
        } catch (err) {
            console.error('âŒ Error attaching speakLast listener:', err);
        }

        // Basic client-side reply generator - will be replaced by server LLM later
        function generateClientReply(plant, userText) {
            const name = plant.nickname || plant.species || 'I';
            const lower = (userText || '').toLowerCase();
            // prioritized intents
            if (/(water|thirst|dry|watered|moist)/i.test(lower)) {
                const opts = [
                    `Thanks â€” ${name} feels refreshed after a drink! My soil appreciates it.`,
                    `A little water is perfect, thank you. ${name} will perk up soon.`,
                    `You're so kind â€” a gentle watering will help my roots.`
                ];
                return opts[Math.floor(Math.random() * opts.length)];
            }
            if (/(hello|hi|hey|how are you)/i.test(lower)) {
                const opts = [
                    `Hello! ${name} is happy you visited and sends a little leaf-wave.`,
                    `${name} is doing well â€” thank you for checking in.`,
                    `Hi â€” ${name} appreciates the attention and is feeling calm.`
                ];
                return opts[Math.floor(Math.random() * opts.length)];
            }
            if (/(bloom|flower|blooming|blossom)/i.test(lower)) {
                const opts = [
                    `Oh, I'm excited about my blooms â€” thank you for noticing!`,
                    `My flowers are a little shy but they're getting there, thanks for caring.`,
                    `I love when you notice my blooms â€” a little extra light helps them open.`
                ];
                return opts[Math.floor(Math.random() * opts.length)];
            }
            if (/(sun|light|sunlight|shade|window|bright)/i.test(lower)) {
                const opts = [
                    `${name} enjoys gentle sunlight â€” a bright spot near a window is lovely.`,
                    `A bit more light would cheer ${name} up, but not direct scorching sun.`,
                    `I'm getting some light â€” thanks for checking. I like filtered sunshine.`
                ];
                return opts[Math.floor(Math.random() * opts.length)];
            }
            // generic, but varied fallbacks
            const generic = [
                `*${name} hums softly* â€” I heard you. Thank you for caring.`,
                `*${name} rustles its leaves* â€” thanks for stopping by, I feel safe and cozy.`,
                `*${name} sways gently* â€” your presence makes me happy.`
            ];
            return generic[Math.floor(Math.random() * generic.length)];
        }

        // Populate manage panel for one or many plants
        function populateManagePanel(plants) {
            const c = document.getElementById('managePhotosContainer');
            if (!c) return;
            // toggle hide if already visible
            if (c.style.display === 'block') { c.style.display = 'none'; return; }
            c.innerHTML = '';
            let any = false;
            plants.forEach(p => {
                if (!p.images || !p.images.length) return;
                any = true;
                const hdr = document.createElement('div'); hdr.className = 'small'; hdr.style.marginTop = '6px'; hdr.textContent = p.nickname || p.species || 'Plant';
                c.appendChild(hdr);
                p.images.forEach(img => {
                    const row = document.createElement('div');
                    row.style.display = 'flex'; row.style.justifyContent = 'space-between'; row.style.alignItems = 'center'; row.style.marginBottom = '8px';
                    row.innerHTML = `<div style='display:flex; gap:8px; align-items:center'><img src='/uploads/${img.filename}' style='width:72px; height:52px; object-fit:cover; border-radius:6px' data-fn='${img.filename}'><div class='small'>${new Date(img.uploadedAt).toLocaleString()}</div></div><div><button class='ghost small' data-plant='${p.id}' data-img='${img.id}' data-fn='${img.filename}'>Delete</button></div>`;
                    c.appendChild(row);
                    const del = row.querySelector('button[data-img]');
                    del.addEventListener('click', async () => {
                        if (!confirm('Delete this photo?')) return;
                        try {
                            const plantId = del.getAttribute('data-plant');
                            const imgId = del.getAttribute('data-img');
                            // try plants delete first, fall back to flowers
                            let url = `/plants/${plantId}/images/${imgId}`;
                            console.log('DELETE request URL:', url);
                            let r = await fetch(url, { method: 'DELETE' });
                            if (!r.ok && r.status === 404) {
                                url = `/flowers/${plantId}/images/${imgId}`;
                                console.log('Fallback DELETE request URL:', url);
                                r = await fetch(url, { method: 'DELETE' });
                            }
                            const txt = await r.text();
                            if (!r.ok) return alert('Failed to delete: ' + (txt || r.status));
                            // remove this manage-row and clear any shown image UI
                            try { row.remove(); } catch (e) { }
                            removeImageUI(del.getAttribute('data-fn'));
                            await loadPlants();
                            if (currentPlant && currentPlant.id === plantId) openChat(plantId);
                            else c.style.display = 'none';
                        } catch (e) { console.error(e); alert('Delete failed: ' + (e && e.message)); }
                    });
                });
            });
            if (!any) c.innerHTML = '<div class="small">No photos to manage.</div>';
            c.style.display = 'block';
        }

        // Global manage button: if a plant is selected show its photos, otherwise show all plants' photos
        const globalManageBtn = document.getElementById('managePhotosBtn');
        if (globalManageBtn) globalManageBtn.addEventListener('click', async () => {
            if (currentPlant) return populateManagePanel([currentPlant]);
            try {
                const r = await fetch('/plants');
                if (!r.ok) return alert('Failed to load plants');
                const data = await r.json();
                populateManagePanel(data);
            } catch (e) { console.error(e); alert('Failed to load plants'); }
        });

        // Voice input using Web Speech API
        let recog = null;
        let listening = false;
        let micPermissionGranted = localStorage.getItem('micPermission');

        // Speech Recognition disabled due to network connectivity issues with Google's backend
        // Users can still type messages normally
        if (false && ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
            const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
            recog = new SR();
            recog.lang = 'en-US';
            recog.interimResults = false;
            recog.continuous = false;
            recog.maxAlternatives = 1;
            recog.maxNetworkRetries = 3;

            // Add these logs to see what's happening
            window.recogDebug = {
                isSupported: true,
                isListening: () => listening,
                start: () => recog.start(),
                stop: () => recog.stop()
            };

            recog.onstart = () => {
                console.log('ðŸŽ¤ Speech recognition started');
                listening = true;
                document.getElementById('voiceBtn').textContent = 'âºï¸ Listening';
            };

            recog.onresult = (ev) => {
                console.log('ðŸŽ¤ Got result:', ev.results);
                if (ev.results && ev.results[0]) {
                    const t = ev.results[0][0].transcript;
                    console.log('ðŸ“ Transcript:', t);
                    document.getElementById('replyText').value = t;
                }
            };

            recog.onerror = (ev) => {
                console.error('Speech error:', ev.error);
                const voiceBtn = document.getElementById('voiceBtn');
                listening = false;

                if (ev.error === 'not-allowed') {
                    voiceBtn.textContent = 'ðŸŽ¤ Blocked';
                    alert('Microphone access blocked.\n\nGo to:\nSettings â†’ Apps â†’ Chrome â†’ Permissions â†’ Microphone â†’ Allow');
                } else if (ev.error === 'network') {
                    voiceBtn.textContent = 'ðŸŽ¤ No Internet';
                    console.log('ðŸŽ¤ Network error - Check your internet connection');
                    alert('Network error. Please check your internet connection and try again.');
                } else if (ev.error === 'no-speech') {
                    voiceBtn.textContent = 'ðŸŽ¤ No sound';
                    console.log('ðŸŽ¤ No speech detected - try speaking louder');
                    setTimeout(() => {
                        voiceBtn.textContent = 'ðŸŽ¤';
                    }, 1500);
                } else if (ev.error === 'audio-capture') {
                    voiceBtn.textContent = 'ðŸŽ¤ No mic';
                    alert('Microphone not detected or not working');
                } else {
                    voiceBtn.textContent = 'ðŸŽ¤ Error';
                    console.error('Full error details:', ev.error);
                }

                setTimeout(() => {
                    voiceBtn.textContent = 'ðŸŽ¤';
                }, 2000);
            };

            recog.onend = () => {
                listening = false;
                const voiceBtn = document.getElementById('voiceBtn');
                if (voiceBtn) voiceBtn.textContent = 'ðŸŽ¤'
            };
        } else {
            const voiceBtn = document.getElementById('voiceBtn');
            if (voiceBtn) {
                voiceBtn.disabled = true;
                voiceBtn.textContent = 'âŒ';
            }
        }

        // Voice button listener is already attached above at line 3836, no need for duplicate

        // initial load - show plants by default
        setTimeout(async () => {
            try {
                await loadPlants();
                console.log('âœ“ Plants loaded on page load');
            } catch (e) {
                console.error('Error loading plants:', e);
            }
        }, 100);

        // Compare with previous handler: ask the server to compare the latest image to the previous one
        const compareBtn = document.getElementById('compareBtn');
        if (compareBtn) compareBtn.addEventListener('click', async () => {
            if (!currentPlant) return alert('Choose a plant first');
            try {
                // pick the most recent image for this plant
                const imgs = currentPlant.images || [];
                if (!imgs.length) return alert('No images to compare');
                const last = imgs[imgs.length - 1];
                // Call the reply endpoint with a simple prompt asking for a comparison
                const payload = { plantId: currentPlant.id, text: 'Compare the latest image with the previous one and describe growth or changes.', imageId: last.id };
                const headers = { 'Content-Type': 'application/json' };
                if (INVITE_TOKEN) headers['x-invite-token'] = INVITE_TOKEN;
                showTyping();
                const r = await fetch('/reply', { method: 'POST', headers, body: JSON.stringify(payload) });
                const jd = await r.json();
                hideTyping();
                if (r.ok && jd && jd.reply) {
                    const time = new Date().toISOString();
                    const hist = loadConv(currentPlant.id); hist.push({ role: 'user', text: payload.text, time, text_en: payload.text, text_kn: payload.text }); saveConv(currentPlant.id, hist);
                    hist.push({ role: 'plant', text: jd.reply, time: new Date().toISOString(), imageId: jd.imageId || null, growthDelta: jd.growthDelta || null, text_en: jd.text_en || jd.reply, text_kn: jd.text_kn || jd.reply }); saveConv(currentPlant.id, hist);
                    appendMessageEl('plant', jd.reply, new Date().toISOString(), jd.imageFilename || null, jd.imageId || null, jd.growthDelta || null, jd.text_en || jd.reply, jd.text_kn || jd.reply);
                    speak(jd.reply);
                } else {
                    alert('Compare failed');
                }
            } catch (e) { hideTyping(); console.error(e); alert('Compare failed: ' + (e && e.message)); }
        });
    </script>
    <!-- Modal backdrop for manage UI -->
    <div id="modalBackdrop" class="modal-backdrop" aria-hidden>
        <div class="modal" role="dialog" aria-modal="true" id="manageModal">
            <div class="modal-header">
                <div class="modal-title">Manage photos</div>
                <div class="modal-actions">
                    <button id="modalAddBtn" class="manage-add">Add photo</button>
                    <button id="modalCloseBtn" class="ghost small">Close</button>
                </div>
            </div>
            <div id="modalContent" class="gallery"></div>
        </div>
    </div>

    <!-- Upload modal (moved out of left panel to avoid clipping/overflow) -->
    <div id="uploadPanel" class="collapsed" aria-hidden>
        <div class="modal" role="dialog" aria-modal="true" style="max-width:540px; width:100%;">
            <div style="display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:10px;">
                <h4 style="margin:0; font-size:14px;">Upload a plant or flower photo</h4>
                <button id="closeUploadBtn" class="ghost small">Close</button>
            </div>
            <form id="uploadForm">
                <div class="upload-row">
                    <div class="upload-card">
                        <label class="file-area">
                            <input type="file" id="photo" name="photo" accept="image/*" required style="display:none" />
                            <img id="photoPreview" src="" alt="preview" style="display:none">
                            <div id="filePlaceholder" style="text-align:center; padding:6px 8px">
                                <div style="font-size:12px; color:var(--muted)">No photo selected</div>
                                <div style="margin-top:6px"><span class="file-btn">Choose photo</span></div>
                            </div>
                        </label>
                        <div class="upload-fields">
                            <select id="ownerSelect" name="owner" class="pill" style="flex:1">
                                <option value="">Select Owner...</option>
                                <option value="mother">ðŸ‘©â€ðŸ¦° Amma</option>
                                <option value="friend">ðŸ‘§ Ammulu</option>
                            </select>
                            <input id="nickname" name="nickname" class="pill" type="text"
                                placeholder="Nickname (optional)" />
                            <div style="display:flex; gap:8px; align-items:center">
                                <button type="submit" class="primary">Upload</button>
                                <button type="button" id="clearPhoto" class="ghost">Clear</button>
                            </div>
                        </div>
                    </div>
                </div>
            </form>
        </div>
    </div>

    <script>
        // show a centered manage modal for a plant
        function showManageModal(plant) {
            const bd = document.getElementById('modalBackdrop');
            const content = document.getElementById('modalContent');
            const title = document.querySelector('.modal-title');
            const addBtn = document.getElementById('modalAddBtn');
            if (!bd || !content || !title || !addBtn) return;
            title.textContent = plant.nickname || plant.species || 'Plant';
            content.innerHTML = '';
            if (!plant.images || !plant.images.length) {
                content.innerHTML = '<div class="empty">No photos yet.</div>';
            } else {
                plant.images.forEach(img => {
                    const it = document.createElement('div'); it.className = 'item';
                    const im = document.createElement('img'); im.src = `/uploads/${img.filename}`; im.alt = img.filename; im.style.cursor = 'pointer';
                    const del = document.createElement('button'); del.className = 'delete-btn'; del.innerHTML = 'ðŸ—‘'; del.title = 'Delete'; del.setAttribute('aria-label', 'Delete photo');
                    it.appendChild(im); it.appendChild(del); content.appendChild(it);
                    // click thumbnail to open chat and focus this image
                    im.addEventListener('click', (ev) => { ev.stopPropagation(); closeManageModal(); openChat(plant.id, img.id); });
                    del.addEventListener('click', async (ev) => {
                        ev.stopPropagation();
                        const ok = await showConfirm('Delete photo', 'Are you sure you want to delete this photo?');
                        if (!ok) return;
                        try {

                            const delOpts = { method: 'DELETE' };
                            if (INVITE_TOKEN) delOpts.headers = { 'x-invite-token': INVITE_TOKEN };

                            // Use explicit subject type if available to pick correct endpoint deterministically
                            const kind = plant._type === 'flower' ? 'flowers' : 'plants';
                            const url = `/${kind}/${plant.id}/images/${img.id}`;
                            const r = await fetch(url, delOpts);
                            const txt = await r.text();
                            if (!r.ok) return alert('Delete failed: ' + (txt || r.status));

                            // remove from UI
                            removeImageUI(img.filename);

                            // Refresh only the appropriate list based on which endpoint succeeded
                            // Heuristic: if the first delete returned ok then it was a plant, else flower
                            try {
                                // Refresh the proper list based on subject type and refresh modal if subject remains
                                if (plant._type === 'flower') {
                                    await loadFlowers();
                                    try { const res2 = await fetch(`/flowers/${plant.id}`); if (res2.ok) { const p2 = await res2.json(); showManageModal(Object.assign({ _type: 'flower' }, p2)); } else closeManageModal(); } catch (e) { closeManageModal(); }
                                } else {
                                    await loadPlants();
                                    try { const res2 = await fetch(`/plants/${plant.id}`); if (res2.ok) { const p2 = await res2.json(); showManageModal(Object.assign({ _type: 'plant' }, p2)); } else closeManageModal(); } catch (e) { closeManageModal(); }
                                }
                            } catch (e) { closeManageModal(); }
                        } catch (e) { console.error(e); alert('Delete failed'); }
                    });
                });
            }

            addBtn.onclick = (ev) => { ev.stopPropagation(); closeManageModal(); openUploadForPlant(plant.id); };
            document.getElementById('modalCloseBtn').onclick = closeManageModal;
            bd.style.display = 'flex';
        }

        function closeManageModal() { const bd = document.getElementById('modalBackdrop'); if (bd) bd.style.display = 'none'; }

        // Tiny confirm dialog implemented with promise
        function showConfirm(title, msg) {
            return new Promise((resolve) => {
                const wrapper = document.createElement('div'); wrapper.style.position = 'fixed'; wrapper.style.inset = '0'; wrapper.style.display = 'flex'; wrapper.style.alignItems = 'center'; wrapper.style.justifyContent = 'center'; wrapper.style.zIndex = 140;
                const dlg = document.createElement('div'); dlg.className = 'confirm-dialog';
                dlg.innerHTML = `<div style='font-weight:700'>${title}</div><div style='margin-top:8px'>${msg}</div>`;
                const actions = document.createElement('div'); actions.className = 'confirm-actions';
                const no = document.createElement('button'); no.className = 'ghost small'; no.textContent = 'Cancel';
                const yes = document.createElement('button'); yes.className = 'primary'; yes.textContent = 'Delete';
                actions.appendChild(no); actions.appendChild(yes); dlg.appendChild(actions); wrapper.appendChild(dlg); document.body.appendChild(wrapper);
                no.onclick = () => { wrapper.remove(); resolve(false); };
                yes.onclick = () => { wrapper.remove(); resolve(true); };
            });
        }

        // ============================================================================
        // GROWTH CHART VISUALIZATION
        // ============================================================================
        let growthChart = null;

        function displayGrowthChart(plant) {
            const canvas = document.getElementById("growthCanvas");
            if (!canvas) return;

            // Chart is intentionally hidden to keep UI clean and focus on chat experience
            document.getElementById("growthChartContainer").style.display = "none";
            return;
        }

        // ============================================================================
        // GROWTH TRACKING PROMPT
        // ============================================================================

        function displayGrowthPrompt(plant) {
            const images = plant.images || [];

            // Only show prompt if plant has 1 image (needs 2nd for growth tracking)
            if (images.length !== 1) return;

            const messagesContainer = document.getElementById('messages');
            if (!messagesContainer) return;

            // Check if prompt already exists
            if (document.getElementById('growthPrompt')) return;

            const promptEl = document.createElement('div');
            promptEl.id = 'growthPrompt';
            promptEl.style.cssText = 'margin: 12px 0; padding: 12px; background: linear-gradient(135deg, #f0fdf4 0%, #f0fff3 100%); border-left: 4px solid #40916c; border-radius: 6px; font-size: 13px; line-height: 1.5;';

            promptEl.innerHTML = `
                <div style="display: flex; gap: 10px; align-items: flex-start;">
                    <span style="font-size: 18px; flex-shrink: 0;">ðŸ“¸</span>
                    <div style="flex: 1;">
                        <strong style="color: #2d6a4f;">Ready to track growth?</strong>
                        <p style="margin: 6px 0 0 0; color: #1b4332;">Upload a follow-up photo to see how much ${plant.nickname || plant.species} has grown!</p>
                        <button id="uploadForGrowthBtn" style="margin-top: 8px; padding: 6px 12px; background: #40916c; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">Take Photo</button>
                    </div>
                </div>
            `;

            // Add prompt to the end of messages
            messagesContainer.appendChild(promptEl);

            // Wire up the button
            const btn = promptEl.querySelector('#uploadForGrowthBtn');
            if (btn) {
                btn.addEventListener('click', () => {
                    // Close the modal if it's open and open upload for this plant
                    document.getElementById('openUploadBtn')?.click();
                });
            }
        }

        // ============================================================================
        // HEALTH STATUS DASHBOARD
        // ============================================================================

        function updateHealthDashboard(plant) {
            const dashboard = document.getElementById("healthDashboard");
            if (!dashboard) return;

            const profile = plant.profile || {};
            const images = plant.images || [];

            // Show dashboard if: has growth data OR has care history OR multiple photos
            const hasGrowthData = images.length >= 2;
            const hasCareHistory = profile.careHistory && profile.careHistory.length > 0;
            const shouldShow = hasGrowthData || hasCareHistory;

            dashboard.style.display = shouldShow ? "block" : "none";

            if (!shouldShow) return;

            // Update health status with color
            const statusEl = document.getElementById("healthStatus");
            if (statusEl && profile.healthStatus) {
                const status = profile.healthStatus;
                let color = "#e0f2fe"; // default blue (stable)
                if (status === "thriving") color = "#dcfce7"; // light green
                if (status === "stressed") color = "#fee2e2"; // light red
                statusEl.textContent = status.charAt(0).toUpperCase() + status.slice(1);
                statusEl.style.background = color;
            }

            // Update care score
            const scoreEl = document.getElementById("careScore");
            if (scoreEl) {
                scoreEl.textContent = (profile.careScore || 50) + "/100";
            }

            // Update last watered
            const wateredEl = document.getElementById("daysSinceWatering");
            if (wateredEl && profile.lastWatered) {
                const daysSince = Math.floor((Date.now() - new Date(profile.lastWatered).getTime()) / (1000 * 60 * 60 * 24));
                wateredEl.textContent = daysSince + " day(s) ago";
                wateredEl.style.color = daysSince > 7 ? "#d32f2f" : "var(--muted)";
            } else if (wateredEl) {
                wateredEl.textContent = "Not recorded yet";
            }

            // Update care style
            const styleEl = document.getElementById("careStyle");
            if (styleEl && profile.userCareStyle && profile.userCareStyle !== "unknown") {
                styleEl.textContent = profile.userCareStyle.replace(/_/g, " ");
            } else if (styleEl) {
                styleEl.textContent = "unknown (mention in chat)";
            }
        }

        // ============================================================================
        // PHOTO COMPARISON MODAL
        // ============================================================================

        function openCompareModal(plant, idx1, idx2) {
            const images = plant.images || [];
            if (idx1 < 0 || idx1 >= images.length || idx2 < 0 || idx2 >= images.length) return;

            const img1 = images[idx1];
            const img2 = images[idx2];
            
            // Build image URLs with API_BASE_URL if available
            const imgBaseUrl = (typeof API_BASE_URL !== 'undefined' && API_BASE_URL) 
              ? API_BASE_URL + '/uploads/' 
              : '/uploads/';
            const img1Url = imgBaseUrl + img1.filename;
            const img2Url = imgBaseUrl + img2.filename;

            let modal = document.getElementById("compareModal");
            if (!modal) {
                modal = document.createElement("div");
                modal.id = "compareModal";
                modal.className = "compare-modal";
                document.body.appendChild(modal);
            }

            const growth = img1.area && img2.area ? Math.round(((img2.area - img1.area) / img1.area) * 100) : null;

            modal.innerHTML = `
                <div class="compare-modal-content">
                    <button class="compare-modal-close" onclick="document.getElementById('compareModal').classList.remove('show'); document.getElementById('compareModal').style.display='none'">&times;</button>
                    <h3>Photo Comparison</h3>
                    <div class="compare-grid">
                        <div>
                            <p style="margin: 0 0 8px 0;"><strong>Photo ${idx1 + 1}</strong></p>
                            <img src="${img1Url}" />
                            <p class="compare-info">Date: ${new Date(img1.uploadedAt).toLocaleDateString()}<br>Area: ${(img1.area * 100).toFixed(1)}%</p>
                        </div>
                        <div>
                            <p style="margin: 0 0 8px 0;"><strong>Photo ${idx2 + 1}</strong></p>
                            <img src="${img2Url}" />
                            <p class="compare-info">Date: ${new Date(img2.uploadedAt).toLocaleDateString()}<br>Area: ${(img2.area * 100).toFixed(1)}%</p>
                        </div>
                    </div>
                    ${growth !== null ? `<div style="margin-top: 20px; padding: 12px; background: var(--accent-2); border-radius: 6px; font-weight: bold; color: #1a1a1a;">Growth: ${growth > 0 ? '+' : ''}${growth}%</div>` : ''}
                </div>
            `;

            modal.classList.add("show");
            modal.style.display = "flex";
        }

        function closeCompareModal() {
            const modal = document.getElementById("compareModal");
            if (modal) {
                modal.classList.remove("show");
                modal.style.display = "none";
            }
        }

        // ============================================================================
        // MILESTONE CELEBRATIONS
        // ============================================================================

        function checkMilestones(plant) {
            const profile = plant.profile || {};
            const adoptedDate = new Date(profile.adoptedDate);
            const daysOld = (Date.now() - adoptedDate.getTime()) / (1000 * 60 * 60 * 24);

            const milestones = [];
            if (daysOld >= 7 && !profile.milestones?.oneWeek) {
                milestones.push({ name: "1 Week Together!", emoji: "ðŸŽ‰", days: 7 });
                profile.milestones = profile.milestones || {};
                profile.milestones.oneWeek = true;
            }
            if (daysOld >= 30 && !profile.milestones?.oneMonth) {
                milestones.push({ name: "1 Month Together!", emoji: "ðŸŽŠ", days: 30 });
                profile.milestones = profile.milestones || {};
                profile.milestones.oneMonth = true;
            }
            if (daysOld >= 180 && !profile.milestones?.sixMonths) {
                milestones.push({ name: "6 Months Together!", emoji: "ðŸŒŸ", days: 180 });
                profile.milestones = profile.milestones || {};
                profile.milestones.sixMonths = true;
            }
            if (daysOld >= 365 && !profile.milestones?.oneYear) {
                milestones.push({ name: "1 Year Together!", emoji: "ðŸ†", days: 365 });
                profile.milestones = profile.milestones || {};
                profile.milestones.oneYear = true;
            }

            return milestones;
        }

        function displayMilestones(plant) {
            const milestones = checkMilestones(plant);
            if (milestones.length === 0) return;

            const messagesDiv = document.getElementById("messages");
            for (const milestone of milestones) {
                const mEl = document.createElement("div");
                mEl.className = "milestone-celebration";
                mEl.innerHTML = `<div class="emoji">${milestone.emoji}</div><div>${milestone.name}</div>`;
                messagesDiv.appendChild(mEl);
            }
        }

        // ============================================================================
        // ANALYTICS DASHBOARD
        // ============================================================================

        async function loadAnalytics() {
            try {
                const res = await fetch("/analytics/plants");
                if (!res.ok) return;

                const data = await res.json();
                if (!data.success) return;

                const list = document.getElementById("analyticsList");
                if (!list) return;

                list.innerHTML = "";

                const sorted = (data.analytics || []).sort((a, b) => (b.careScore || 0) - (a.careScore || 0));

                sorted.forEach((p, i) => {
                    const card = document.createElement("div");
                    card.className = "analytics-card";
                    const champion = i === 0 ? '<div class="champion">ðŸ† Best Cared For!</div>' : i === 1 ? '<div class="champion">ðŸ¥ˆ Second Best</div>' : '';
                    card.innerHTML = `
                        <h4>${p.nickname || p.species}</h4>
                        <p style="font-size: 12px; color: var(--muted); margin: 4px 0;">${p.species}</p>
                        <div class="stat">
                            <div>ðŸ“· Photos: ${p.totalPhotos}</div>
                            <div>ðŸ“ˆ Latest Growth: ${p.latestGrowth ? (p.latestGrowth > 0 ? '+' : '') + p.latestGrowth + '%' : 'N/A'}</div>
                            <div>ðŸ’š Status: ${p.healthStatus}</div>
                            <div>â­ Care Score: ${p.careScore}/100</div>
                            <div>ðŸ“… Days Old: ${p.adoptedDays}</div>
                        </div>
                        ${champion}
                    `;
                    list.appendChild(card);
                });
            } catch (e) {
                console.error("Analytics load failed:", e);
            }
        }
    </script>
</body>

</html>